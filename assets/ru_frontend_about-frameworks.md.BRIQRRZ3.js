import{_ as s,o as e,c as a,a4 as t}from"./chunks/framework.B8KxSsRZ.js";const m=JSON.parse('{"title":"О фронтенд фреймворках","description":"","frontmatter":{},"headers":[],"relativePath":"ru/frontend/about-frameworks.md","filePath":"ru/frontend/about-frameworks.md","lastUpdated":1728438031000}'),i={name:"ru/frontend/about-frameworks.md"},p=t(`<h1 id="о-фронтенд-фреимворках" tabindex="-1">О фронтенд фреймворках <a class="header-anchor" href="#о-фронтенд-фреимворках" aria-label="Permalink to &quot;О фронтенд фреймворках&quot;">​</a></h1><details class="details custom-block"><summary>Что такое &quot;реактивность&quot;?</summary><p>Наверное, самое фундаментальное отличие программы для фронта от программы для бэка, микросервиса и даже отдельного приложения с GUI, это понятие &quot;<strong>реактивности</strong>&quot;.</p><p>При работе на бэке программист имеет хорошие возможности управлять потоком данных. Он контролирует откуда их брать, куда передавать, кто их может изменить, всё это хоть в одном потоке, хоть в многопоточной системе.</p><p>На фронте большую роль играет фактор интерактивности UI - данные надо динамично показывать пользователю, пользователь может изменять данные, данные могут изменяться различными контрагентами (пользователь, бэкенд, внутренние вычисления). В принципе, возможно использовать обычные программистские подходы как и на бэке, - то есть, самому следить за изменениями данных в каждом месте, и проводить обновление всех зависимостей. Это даст очень много бойлерплейта - рутинного повторяющегося кода. Реактивные фреймворки сильно облегчили жизнь программистам, взяв на себя заботу об этом обновлении зависимостей переменной при её изменении.</p><p>В реактивном фреймворке достаточно задать реактивную переменную и указать, что она является, например, значением input поля. При вводе пользователем в это поле значения переменная автоматически обновится, и все другие переменные, зависящие от нее, тоже. Кода писать для этого не надо.</p><p>Упрощенно говоря, под капотом реактивная переменная это прокси-обертка над обычной, которая следит за её изменениями и регистрирует всех слушателей, которых надо оповестить об изменении переменной, чтобы они себя пересчитали.</p></details><details class="details custom-block"><summary>Какие реактивные фронтенд фреймворки существуют</summary><p>React, Vue, Angular - самые распространенные. Есть множество других, не взлетевших.</p><p>Angular используется обычно для больших проектов (больших команд разного уровня программистов) и жестко зажимает разработку в свои правила.</p><p>React и Vue более гибки и схожи, но есть существенные отличия.</p><p>Vue быстрей, меньше, эффективней, не смешивает HTML и JS, имеет меньший порог входа. Активно развивается.</p><p>За React-ом Цукерберг и бо́льшая распространенность. Больше предложений о работе, но и больше кандидатов на одно место.</p></details><details class="details custom-block"><summary>Почему Vue?</summary><p>Чтобы можно было разрабатывать и управлять большими сложными программными системами, было изобретено ООП - объектно-ориентированное программирование, где для иерархичного разбиения сложности вводились новые сущности - объекты. Они инкапсулировали в себе данные и поведение (логику).</p><p>На фронтенде немного иная ситуация из-за наличия кода на нескольких языках программирования - HTML, CSS, JavaScript. И в данном случае SFC компоненты во Vue отлично служат для разбиения сложности системы. Каждый компонент инкапсулирует HTML шаблон, его стилизацию и логику.</p><p>Vue делает это намного лучше, чем тот же React, который сваливает всё в одну кучу. В этом аспекте Vue однозначно является флагманом компонентно-ориентированного программирования (КОП) на фронтэнде.</p><p>Кроме того, во Vue 3 появилась реактивность за пределами компонент - <code>ref</code> и <code>reactive</code> переменные можно задать в простом <code>js</code> модуле. Это используется в <code>composable</code> функциях. Стало возможно отделить от представления не только реактивный сервис (<code>useI18n</code>, <code>useScreenSize</code> например), но и бизнес-логику (<code>useShoppingCart</code>, <code>useNewsWidget</code>). Это позволяет использовать на фронтенде <a href="https://ru.wikipedia.org/wiki/Model-View-Controller" target="_blank" rel="noreferrer">MVC шаблон</a>, где роли <code>View</code> и частично <code>Controller</code> выполняют компоненты, отвечающие преимущественно за визуализацию, а логика и модель (<code>Model</code> и частично <code>Controller</code>) приходятся на composable функции и их реактивный стейт.</p><p>Это даёт возможность сделать, например, смену дизайна сайта или замену UI библиотеки намного более легкой задачей.</p><p>Данная особенность также сильно выделяет Vue на фоне других реактивных фреймворков-аналогов.</p><p>Reactivity API во Vue 3, возможно, еще не идеально (именно поэтому Эван Ю экспериментировал с reactivity Transform), но уже вполне подходит для разработки больших, надежных, масштабируемых систем, чего нельзя было сказать о Vue 2.</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>Реактивностью Vue можно пользоваться совсем без UI. Например, в <a href="https://github.com/soerenuhrbach/vscode-deepl/blob/main/src/state.ts" target="_blank" rel="noreferrer">этом расширении VS Code</a> элементы Vue 3 <code>reactive</code>, <code>ref</code> и <code>watch</code> используются для организации реактивности в коде без визуальных компонент.</p></div></details><details class="details custom-block"><summary>Что может Vue, но не могут React или Svelte?</summary><p>Vue эффективней работает с реактивностью.</p><p>Добавление нового элемента в массив:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// React</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setSomeArr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">someArr, newItem]);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Svelte</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">someArr </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">someArr, newItem];</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Vue</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">someArr.value.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(newItem.value);</span></span></code></pre></div><p>Использование нативного ES6 объекта Proxy позволяет избежать декомпозиции и создания промежуточного массива. Также это более производительное решение.</p></details>`,5),o=[p];function l(n,r,c,d,h,u){return e(),a("div",null,o)}const g=s(i,[["render",l]]);export{m as __pageData,g as default};
