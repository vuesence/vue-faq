import{_ as e,c as t,o,U as a}from"./chunks/framework.P5TqXf0g.js";const b=JSON.parse('{"title":"State management во Vue 3","description":"","frontmatter":{},"headers":[],"relativePath":"ru/development/stores.md","filePath":"ru/development/stores.md","lastUpdated":1706271549000}'),s={name:"ru/development/stores.md"},i=a('<h1 id="state-management-во-vue-3" tabindex="-1">State management во Vue 3 <a class="header-anchor" href="#state-management-во-vue-3" aria-label="Permalink to &quot;State management во Vue 3&quot;">​</a></h1><details class="details custom-block"><summary>Зачем нужен State management?</summary><p>Иногда в приложении нужно передать реактивные данные или функцию из одного компонента в другой, и эти компоненты не принадлежат одной иерархии. Механизмы пропсов/ивентов или provide/inject не подходят для этого. Поэтому во Vue 2 появился Vuex - state management библиотека, которая позволяет хранить реактивный стейт и предоставлять доступ к нему отовсюду.</p><p>Библиотека управления стейтом на фронтенде обычно называется &quot;стором&quot;.</p></details><details class="details custom-block"><summary>Как можно передать реактивные данные из одного компонента в другой во Vue 3?</summary><ul><li>Если один компонент является прямым потомком другого - пропсы и ивенты</li><li>Если один компонент непрямой потомок другого - provide/inject или проп/ивент дриллинг (плохая практика)</li><li>Если они в разных ветках иерархии - стор или Vue 3 ref/reactive</li></ul><p>Vue 3 ref/reactive - это когда в отдельном js модуле вы определяете и экспортируете реактивную переменную:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>export const userLoggedIn = ref(false);</span></span></code></pre></div><p>После чего она доступна во всём приложении через импорт данного модуля.</p><p>Однако, расшаривать просто переменную - архитектурно плохая идея. Обычно вокруг этой переменной есть бизнес логика, которую и надо сделать доступной.</p><p>Например, для аутентификации нужен не только сам факт, что пользователь залогинился, но и сопутствующие методы - <code>login()</code>, <code>logout()</code>, <code>register()</code>, <code>isAuthenticated()</code>. Синтез некоего стейта и сопутствующей бизнес логики дал так называемые composable функции во Vue 3.</p><p>В некотором смысле - аналог объекта в ООП.</p></details><details class="details custom-block"><summary>Что такое стор (store) на фронтенде?</summary><blockquote><p><em>A Store (like Pinia) is an entity holding state and business logic that isn&#39;t bound to your Component tree. In other words, it hosts global state. It&#39;s a bit like a component that is always there and that everybody can read off and write to.</em></p><p><em>Стор (например, Pinia) — это сущность, содержащая состояние и бизнес-логику, которая не привязана к вашему дереву компонентов. Другими словами, здесь находится глобальное состояние. Это что-то вроде компонента, который всегда присутствует, и который каждый может считывать и писать в него.</em></p><p><em>Официальная документация Pinia</em></p></blockquote><p>Выглядит как очень неудачное, двусмысленное и запутывающее определение.</p><p>С точки зрения разработчика не фронтенда (по сути любой другой язык, кроме JavaScript, плюс частично JavaScript), аналогом конструкции с названием<code>стор</code> будет база данных - SQL, NoSQL или кэширующий Redis. Там есть аналоги стейта и геттеров (<code>View</code> в SQL БД). Но в 99.99% случаях в базе данных не будет никакой бизнес логики, за исключением ограничений для консистентности данных (например, unique или foreign keys).</p><p>С точки зрения разработчика не фронтенда, сторы фронтенда - это просто объекты / stateful сервисы, построенные по шаблону <code>синглтон</code>. Называть их <em>&quot;глобальными сторами&quot;</em> как минимум нелогично.</p><p>Скорей всего, это произошло исторически. Сперва был один Vuex, он был один стор и глобален. Потом у него появились модули. Потом у Pinia эти модули стали независимы и расползлись по всему приложению. В итоге, в приложении куча мелких локальных (по области использования) сторов, каждый из которых считает себя глобальным, даже если его использует 2-3 компонента из 1000 на проекте, и даже если в этом сторе 1% - стейта, и 99% - бизнес и сопутствующей логики.</p><p>В этом плане использование композабл функций для той же цели (<em>an entity holding state and business logic that isn&#39;t bound to your Component tree</em>) - намного более логично. И называть их следует не useAuthStore, а useAuth или useAuthService.</p></details><details class="details custom-block"><summary>Vuex или Pinia?</summary><p>Во Vue 3 основной внешней библиотекой управления стейтом стала Pinia. В отличие от Vuex у нее есть поддержка TypeScript, она удобней и, естественно, пользуется преимуществами Vue 3.</p><p>Vuex официально устарел (deprecated)</p></details><details class="details custom-block"><summary>Pinia или Composable functions?</summary><p>Во Vue 3 появилось нечто, делающее отдельную библиотеку для управления стейтом ненужной. А именно, реактивные типы<code>Ref</code> и <code>Reactive</code>, которыми можно пользоваться за пределами компонент. Стало возможным делать свои сторы на основе composable функций и подключать их в любом компоненте.</p><p>Основное декларируемое отличие Pinia - интеграция с Vue DevTools, плагины и SSR поддержка. Однако, нужно ли ему то или другое, каждый разработчик решает сам. Работать с composables в DevTools вполне комфортно.</p><p>Composable функция, в свою очередь, может иметь как глобальный, так и локальный (переменные объявлены внутри функции) стейты. Это бывает удобно в определенных случаях - можно создать несколько экземпляров composable функций, каждая со своим стейтом. Например, когда у вас на сайте несколько новостных виджетов, различающихся только категорией новостей.</p><p>Кроме того, с функциональной точки зрения composable функции имеют полный доступ ко всему Vue Reactivity API, что делает их гибче, чем Pinia.</p><p>Composable функции с глобальным стейтом не работают в SSR режиме.</p><p>Что касается производительности, то <a href="https://github.com/vuesence/pinia-vs-reactive" target="_blank" rel="noreferrer">по тестам</a> на изменениях Reactive Pinia примерно в полтора раза медленней Vue 3 Reactive, а на Ref - в 20 раз. Это потому, что Ref (примитивные типы) в Pinia становится частью Reactive. Setup store не решают эту проблему.</p><p>Также надо помнить, что любая зависимость (в данном случае библиотека Pinia) может принести проблемы, аналогичные с ситуацией &quot;RIP Vuex&quot;, когда библиотека умирает, устаревает, перестает поддерживаться или в ней находят уязвимости. Composable функции, в свою очередь, выглядят основательным нововведением во Vue фреймворк.</p><p>Вот <a href="https://www.reddit.com/r/vuejs/comments/18fnilj/why_to_use_pinia_instead_of_global_refs/" target="_blank" rel="noreferrer">интересное обсуждение</a> по теме на <em>/r/vuejs</em>. <a href="https://github.com/jellyfin/jellyfin-vue/blob/master/frontend/src/store/clientSettings.ts#L98" target="_blank" rel="noreferrer">Пример кода</a> от Reddit пользователя <strong>@ferferga</strong> показывает, как использовать классы TypeScript с private методами, геттерами, сеттерами (без <em>.value</em>) и поддержкой типов первого класса в качестве store на Composition API (что было бы невозможно с Pinia). Использование классов TS здесь, возможно, не является хорошей практикой, но демонстрирует гибкость и мощь Composition API.</p><p>Также вот лайфхак для Devtools от пользователя <strong>@coolcosmos</strong>: <em>Я просто использую рефы. Минус в том, что вы теряете Devtools, но в режиме разработки я временно импортирую все свои рефы и передаю их в Pinia, так что у меня есть все плюсы и никаких минусов</em>.</p></details><details class="details custom-block"><summary>Как разделять логику между компонентом и composable функциями?</summary><p>Удобно представлять это как <a href="https://ru.wikipedia.org/wiki/Model-View-Controller" target="_blank" rel="noreferrer">MVC шаблон</a>, где роль <code>View</code> (и частично <code>Controller</code>) выполняют компоненты, отвечающие преимущественно за визуализацию, а логика и модель (<code>Model</code> и частично <code>Controller</code>) приходятся на композабл функции и их реактивный стейт.</p><p>Чтобы понять, что класть в композабл, а что в компонент (который может состоять из нескольких компонент), представьте, что вы меняете компонент на другой - отображающий ваши данные как-то иначе. В идеале, модель (композабл) должен остаться тем же самым, вы переписываете только компонент, в котором логика, ответственная только за отображение.</p><p>В то же время, логика (<code>Controller</code>) может делиться между компонентом и композаблом. Например, валидация данных формы может происходить в компоненте (проверка, что поле заполнено), в компоненте с помощью сторонней утилиты (проверка, что пароль - &quot;сложный&quot;) и в композабле (проверка, что username - уникален)</p></details>',7),r=[i];function n(l,p,c,d,m,u){return o(),t("div",null,r)}const g=e(s,[["render",n]]);export{b as __pageData,g as default};
