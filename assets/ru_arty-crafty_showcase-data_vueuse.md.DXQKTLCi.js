import{_ as s,o as a,c as e,a4 as i}from"./chunks/framework.B8KxSsRZ.js";const u=JSON.parse('{"title":"VueUse","description":"","frontmatter":{"pageClass":"arty-crafty","head":[["meta",{"name":"og:site_name","content":"Arty-Crafty - проект онлайн магазина"}],["meta",{"name":"og:image","content":"/images/arty-crafty-logo.png"}],["meta",{"name":"twitter:image","content":"/images/arty-crafty-logo.png"}]]},"headers":[],"relativePath":"ru/arty-crafty/showcase-data/vueuse.md","filePath":"ru/arty-crafty/showcase-data/vueuse.md","lastUpdated":1715838813000}'),t={name:"ru/arty-crafty/showcase-data/vueuse.md"},o=i(`<h1 id="vueuse" tabindex="-1">VueUse <a class="header-anchor" href="#vueuse" aria-label="Permalink to &quot;VueUse&quot;">​</a></h1><h2 id="uselocalstorage" tabindex="-1">useLocalStorage <a class="header-anchor" href="#uselocalstorage" aria-label="Permalink to &quot;useLocalStorage&quot;">​</a></h2><p>В проекте у нас есть несколько переменных, значения которых надо сохранять в <code>LocalStorage</code> - например, <code>isDarkMode</code>, <code>favourites</code>, <code>shoppingCart</code>. Также, для UX полезно, чтобы эта связь была реактивной - тогда при нескольких открытых вкладках изменение корзины или цветовой темы в одной сразу будет отражаться в другой.</p><p>Для этого была реализована <a href="https://github.com/vuesence/arty-crafty/blob/main/src/app/composables/useLocalStorage.ts" target="_blank" rel="noreferrer">своя версия</a> <code>useLocalStorage</code>.</p><p>Любую реактивную переменную проекта можно зарегистрировать в этом композабле, и её значение станет динамично отображаться в <code>LocalStorage</code> и обратно:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// init.ts</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { useLocalStorage } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;@/app/composables/useLocalStorage&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ls</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useLocalStorage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> init</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ls.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">init</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ls.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">observe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;favourites&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, favourites);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ls.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">observe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;isDarkTheme&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, isDarkTheme);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Все переменные будут храниться в одном объекте в <code>LocalStorage</code> , а не каждая в своем.</p><h2 id="библиотека-vueuse" tabindex="-1">Библиотека VueUse <a class="header-anchor" href="#библиотека-vueuse" aria-label="Permalink to &quot;Библиотека VueUse&quot;">​</a></h2><p>VueUse - популярная библиотека, состоящая из небольших утилит. Нисколько не умаляя вклад Anthony Fu в экосистему Vue, опишу, почему я не использую её и не рекомендую для серьезных проектов и опытных разработчиков.</p><ol><li><p>Все утилиты в ней - <strong>небольшие</strong>. Под &quot;небольшие&quot; я подразумеваю, что аналогичный свой код будет в 10-50 строк. В зависимости от обстоятельств и требований, свой код может быть и в пять строк (аналог <code>onClickOutside</code>), и в две (использование <code>LocalStorage</code>). Кроме того, на проект нужно обычно всего 2-3 подобных утилит оттуда. <strong>Подключать из-за этого всю библиотеку нецелесообразно</strong>, несмотря на tree-shaking.</p></li><li><p><strong>Это зависимость</strong>, и как все зависимости может измениться, устареть, получить уязвимость, тормозить развитие проекта и прочее, прочее. С большинством активно развивавшихся библиотек такое случалось.</p></li><li><p>Утилиты в ней <strong>не делают то, что надо именно тебе</strong>. Например, мне для адаптивности нужно ставить соответствующий CSS класс на <code>&lt;body&gt;</code> при изменении ширины экрана. В библиотеке есть две утилиты, работающие с шириной экрана, но ни одна не дает именно то, что надо. Приходится преобразовывать данные от <code>useBreakponts</code> в свои, и весь код занимает половину кода <a href="https://github.com/vuesence/arty-crafty/blob/main/src/app/composables/useScreenWidth.ts" target="_blank" rel="noreferrer">своей реализации</a>, которая достаточно проста и прямолинейна, и вполне может быть даже сгенерирована AI ботом.</p></li><li><p>В утилитах <code>VueUse</code> содержится <strong>избыточная и чрезмерная логика и код</strong> (с точки зрения вашего конкретного проекта). Если бы это был простой js код, было бы еще ничего, но <strong>это реактивный код</strong>. Если открыть исходники <code>useBreakponts</code>, то можно увидеть с десяток <code>computed</code> переменных, которые ты не используешь. Но учитывая, что только в версии 3.4 Vue пофиксила баг, при котором компьютеды пересчитывались, хотя ни одна из входящих в них переменная не менялась, нет никаких гарантий, что при изменении экрана или сдвиге мышки не будет производиться множество не нужных тебе пересчетов. Это влияет на производительность.</p></li><li><p>Указанная выше проблема, это не недостаток именно VueUse. Попробуйте написать универсальный компонент, который любой разработчик мог бы использовать. Примерно за 20% времени вы напишите вполне рабочий, подходящий вашему проекту компонент, и оставшиеся 80% будете лепить на него обвесы, чтобы он был универсальный и опциональный, учитывал Vue 2 и Vue 3, был SSR-safe и еще много чего, что конкретно вам не нужно. В итоге лаконичный красивый эффективный код превратится во <strong>множество проверок, адаптеров и прочей не функциональной логики</strong>. Поэтому написать свой код всегда намного эффективней использования чужого универсального. Речь сейчас идет конкретно про подобные утилитарные библиотеки, а не, к примеру, UI пакеты.</p></li><li><p><code>useLocalStorage</code> от VueUse возвращает реактивную переменную, которую, по идее, нужно напрямую использовать в проекте. Другими словами, если мне надо сохранять в <code>LocalStorage</code> <code>shoppingCart</code>, то ее нужно создать через вызов <code>useLocalStorage()</code>. То есть, одна из основных бизнес-сущностей моего проекта должна создаваться какой-то сторонней библиотекой. <strong>Чужой код простой утилиты диктует реализацию элементов архитектуры всего проекта</strong>. Мне такое кажется абсолютно неприемлимым.</p></li><li><p>Можно создать отдельно <code>shoppingCart</code> и отдельно переменную через <code>useLocalStorage()</code> и затем заморочится с их синхронизацией через <code>watch</code> и предотвращением бесконечных циклов. И это для каждой такой переменной. Можно совсем довериться VueUse и использовать их <code>syncRef</code>. Но это уже даже не неприемлимо, а смешно, не говоря о том, что код в итоге получится больше, чем своё решение. Таким образом, утилиты VueUse бывают <strong>просто неудобными в применении</strong>. <code>Lodash</code> при использовании был очень удобным - берешь её функцию, и она максимально эффективно делает то, что надо. Из того, что я пытался применить в своих проектах, VueUse неудобен.</p></li><li><p>Есть большая разница между популяризацией (хорошо) и популизмом (плохо). Советы по использованию и даже навязывание VueUse разработчикам, без понимания ими того, что именно они получают и за какую цену, смахивает на второе.</p></li></ol><div class="info custom-block"><p class="custom-block-title">Wikipedia</p><p>Попули́зм (от лат. populus — народ) — политика, апеллирующая к широким массам и обещающая им скорое и лёгкое решение острых социальных проблем. В основе популизма лежит стремление той или иной политической силы завоевать доверие и поддержку масс, понравиться народу. При этом реальные цели политиков-популистов (борьба за власть, обогащение и тому подобное), как правило, прикрываются социально-привлекательными идеями.</p></div>`,11),n=[o];function l(p,r,c,h,d,k){return a(),e("div",null,n)}const E=s(t,[["render",l]]);export{u as __pageData,E as default};
