import{_ as a,o as e,c as t,a4 as o}from"./chunks/framework.B8KxSsRZ.js";const s="/assets/baas-adapters.CVuECzFb.webp",S=JSON.parse('{"title":"Выбор BaaS или CMS","description":"","frontmatter":{"pageClass":"arty-crafty","head":[["meta",{"name":"og:site_name","content":"Arty-Crafty - проект онлайн магазина"}],["meta",{"name":"og:image","content":"/images/arty-crafty-logo.png"}],["meta",{"name":"twitter:image","content":"/images/arty-crafty-logo.png"}]]},"headers":[],"relativePath":"ru/arty-crafty/backend/baas-choosing.md","filePath":"ru/arty-crafty/backend/baas-choosing.md","lastUpdated":1715855969000}'),r={name:"ru/arty-crafty/backend/baas-choosing.md"},c=o('<h1 id="выбор-baas-или-cms" tabindex="-1">Выбор BaaS или CMS <a class="header-anchor" href="#выбор-baas-или-cms" aria-label="Permalink to &quot;Выбор BaaS или CMS&quot;">​</a></h1><h2 id="json-фаилы-товаров" tabindex="-1">JSON файлы товаров <a class="header-anchor" href="#json-фаилы-товаров" aria-label="Permalink to &quot;JSON файлы товаров&quot;">​</a></h2><p>Дальнейшая работа с json файлами продуктов и категорий имеет мало смысла - их придется делать несколько, небольшое изменение схемы потребует изменение всех файлов вручную и т.п.</p><p>Проще перейти уже к нормальному бэкенду, с динамичными данными.</p><h2 id="выбор-cms" tabindex="-1">Выбор CMS <a class="header-anchor" href="#выбор-cms" aria-label="Permalink to &quot;Выбор CMS&quot;">​</a></h2><p>После довольно долгого исследования рынка для реализации витрины и, частично, магазина, выбор пал на <code>Supabase</code>.</p><p>Основными критериями при выборе на этом этапе были:</p><ul><li>Простота</li><li>Open source</li><li>Бесплатность при использовании из облачных сервисов (это нужно не только нам, но и тем, кто будет использовать наш проект)</li><li>RDBMS (SQL) в качестве базы данных (почему не подошел Firebase)</li><li>Возможность потом несложно переехать на другой сервис/БД/свой сервер.</li></ul><p>Большинство CMS продуктов предлагает платные low-code решения, завязанные на них и оперирующие не с данными, как нам надо, а с более высокоуровневыми конструкциями для построения сайта.</p><p>Среди Baas (Backend as a Service) решений были рассмотрены Firebase, Appwrite, Supabase, Amplify.</p><p>Модель данных обычного магазина очень хорошо ложится именно на реляционную модель данных, уже давно хорошо зарекомендовавшую себя, в отличие от NoSQL.</p><h2 id="сервисы-supabase" tabindex="-1">Сервисы Supabase <a class="header-anchor" href="#сервисы-supabase" aria-label="Permalink to &quot;Сервисы Supabase&quot;">​</a></h2><p>Supabase предлагает непосредственно Postgres базу данных (можно подсоединяться прямо к ней), API сервис для доступа к базе данных посредством REST запросов, сервис для парольной и OAuth аутентификаций, Edge Functions (серверные функции), на которых можно реализовать логику бэкенда. Лимиты бесплатного плана достаточно большие.</p><p>В дальнейшем возможно разворачивание Postgres на своем сервере и использование Supabase кода через Docker, либо своего API слоя. При желании можно будет даже поменять базу на MySQL. Всё это очень важная гибкость выстраиваемой архитектуры. Если мы чего-то не учтем сейчас, или ошибемся, то потом можно будет внести изменения с некритичными затратами.</p><h2 id="адаптеры" tabindex="-1">Адаптеры <a class="header-anchor" href="#адаптеры" aria-label="Permalink to &quot;Адаптеры&quot;">​</a></h2><p>Мы помним, что одним из факторов успеха при создании сложной системы является её разбиение на слабосвязные более простые подсистемы. Конкретно тут мы имеем подсистемы &quot;База данных&quot;, &quot;Бэкенд (API сервис Supabase)&quot;, наш фронтенд.</p><p>Компоненты фронтенда должны обмениваться данными с API Supabase. Если мы в каждом компоненте будем прописывать обращение к API через <code>Fetch</code> или <code>Axios</code>, то при замене Supabase на другой бэкенд, или на наш свой, по всему коду фронтенда надо будет делать изменения, что очень затратно. Для нивелирования этого вызовы к API выносятся в отдельный модуль - <code>api</code>, и теперь в компонентах будет только вызов <code>api.products()</code>, который при смене бэкенда менять не надо, нужно будет поменять только его реализацию в <code>api</code>.</p><p>В этом случае, мы применяем шаблон проектирования <a href="https://ru.wikipedia.org/wiki/%D0%90%D0%B4%D0%B0%D0%BF%D1%82%D0%B5%D1%80_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)" target="_blank" rel="noreferrer">&quot;Адаптер&quot;</a>. При работе, например, с Firebase нам нужно будет написать другой адаптер, при работе со своим бэкендом - еще один. Каждый из них будет преобразовывать запрос к определенному эндпойнту за списком товаров в массив для возвращения в функции <code>api.products()</code>.</p><p>Когда делают системы широкого пользования, то предусматривают подключение к различным сервисам. Например, тот же Vue Storefront имеет адаптеры для интеграции с API бэкендов Magento, PrestaShop, Spree и других ecommerce решений.</p><p><img src="'+s+'" alt="image"></p><p>Но у нас пока только Supabase, концентрируемся на нём.</p>',21),p=[c];function i(n,d,l,u,h,b){return e(),t("div",null,p)}const D=a(r,[["render",i]]);export{S as __pageData,D as default};
