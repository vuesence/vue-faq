import{_ as e,o as t,c as o,a4 as a}from"./chunks/framework.B8KxSsRZ.js";const f=JSON.parse('{"title":"State management in Vue 3","description":"","frontmatter":{},"headers":[],"relativePath":"en/development/stores.md","filePath":"en/development/stores.md","lastUpdated":1729563759000}'),s={name:"en/development/stores.md"},n=a('<h1 id="state-management-in-vue-3" tabindex="-1">State management in Vue 3 <a class="header-anchor" href="#state-management-in-vue-3" aria-label="Permalink to &quot;State management in Vue 3&quot;">â€‹</a></h1><details class="details custom-block"><summary>Why State management?</summary><p>Sometimes in an application you need to pass reactive data or a function from one component to another, and these components do not belong to the same hierarchy. Props/emits or provide/inject mechanisms are not suitable for this. That&#39;s why Vue 2 introduced Vuex, a state management library that allows you to store a reactive state and provide access to it from anywhere.</p><p>A frontend state management library is usually called a &quot;store&quot;.</p></details><details class="details custom-block"><summary>How can I pass reactive data from one component to another in Vue 3?</summary><ul><li>If one component is a direct descendant of another - props and events</li><li>If one component is an indirect descendant of another - provide/inject or prop/event dribbling (bad practice).</li><li>If they are in different branches of the hierarchy - store or Vue 3 ref/reactive</li></ul><p>Vue 3 ref/reactive is when you define and export a reactive variable in a separate js module:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>export const userLoggedIn = ref(false);</span></span></code></pre></div><p>It is then available throughout the application via the import of this module.</p><p>However, it is architecturally a bad idea to just share a variable. Usually there is business logic around this variable, which should be made available.</p><p>For example, authentication requires not only the fact that the user is logged in, but also the associated methods - <code>login()</code>, <code>logout()</code>, <code>register()</code>, <code>isAuthenticated()</code>. Synthesizing some kind of state and the accompanying business logic yielded the so-called composable functions in Vue 3.</p><p>In some sense, it is an analog of an object in OOP.</p></details><details class="details custom-block"><summary>What is a store on the frontend?</summary><blockquote><p><em>A Store (like Pinia) is an entity holding state and business logic that isn&#39;t bound to your Component tree. In other words, it hosts global state. It&#39;s a bit like a component that is always there and that everybody can read off and write to.</em></p><p><em>Store (such as Pinia) is an entity that contains state and business logic that is not bound to your Component tree. In other words, this is where the global state resides. It&#39;s sort of like a component that is always present, and that anyone can read and write to.</em></p><p>_ <em>Official Pinia</em> documentation.</p></blockquote><p>Looks like a very unfortunate, ambiguous and confusing definition.</p><p>From the perspective of a non-frontend developer (basically any language other than JavaScript, plus partially JavaScript), the analog of a construct called <code>store</code> would be a database - SQL, NoSQL or caching Redis. There are analogs of state and getters (<code>View</code> in SQL database). But in 99.99% of cases, there will be no business logic in the database except for data consistency constraints (e.g., unique or foreign keys).</p><p>From a non-frontend developer&#39;s perspective, frontend stores are just objects / stateful services built on a <code>singleton</code> pattern. Calling them <em>&quot;global stores&quot;</em> is at least illogical.</p><p>It&#39;s likely that this happened historically. First there was one Vuex, it was one store and global. Then it had modules. Then Pinia modules became independent and spread all over the application. As a result, the application has a bunch of small local (by area of use) storages, each of which considers itself global, even if it is used by 2-3 components out of 1000 on the project, and even if this storage has 1% of state and 99% of business and related logic.</p><p>In this respect, using composable functions for the same purpose (<em>an entity holding state and business logic that isn&#39;t bound to your Component tree</em>) - is much more logical. And they should be called useAuth or useAuthService instead of useAuthStore.</p></details><details class="details custom-block"><summary>Vuex or Pinia?</summary><p>In Vue 3, Pinia has become the main external library for managing the stack. Unlike Vuex, it has TypeScript support, is more convenient, and naturally takes advantage of Vue 3.</p><p>Vuex is officially deprecated</p></details><details class="details custom-block"><summary>Pinia or Composables functions?</summary><p>In Vue 3 there is something that makes a separate library for managing the state unnecessary. Namely, reactive types <code>Ref</code> and <code>Reactive</code> that can be used outside of a component. It became possible to make your own storages on the basis of composable functions and connect them in any component.</p><p>The main declared difference of Pinia is integration with Vue DevTools, plugins and SSR support. However, whether he needs one or the other, each developer decides for himself. It is quite comfortable to work with composables in DevTools.</p><p>Composable function, in its turn, can have both global and local (variables are declared inside the function) states. This can be useful in certain cases - you can create several instances of composable functions, each with its own state. For example, when you have several news widgets on your site, differing only by news category.</p><p>Also, from a functional point of view, composable functions have full access to the entire Vue Reactivity API, which makes them more flexible than Pinia.</p><p>Composable functions with global states do not work in SSR mode.</p><p>As for performance, <a href="https://github.com/vuesence/pinia-vs-reactive" target="_blank" rel="noreferrer">according to tests</a> Pinia is about 1.5 times slower on Reactive changes than Vue 3, and 20 times slower on Ref. This is because Ref (primitive types) in Pinia becomes a part of Reactive. Setup stores does not solve this problem.</p><p>You should also keep in mind that any dependency (in this case the Pinia library) can bring problems similar to the &quot;RIP Vuex&quot; situation when the library dies, becomes obsolete, is no longer supported, or vulnerabilities are found in it. Composable features, on the other hand, look like a thorough innovation to the Vue framework.</p><p>Here is an <a href="https://www.reddit.com/r/vuejs/comments/18fnilj/why_to_use_pinia_instead_of_global_refs/" target="_blank" rel="noreferrer">interesting discussion</a> about it on <em>/r/vuejs</em>. <a href="https://github.com/jellyfin/jellyfin-vue/tree/master/frontend/src/store" target="_blank" rel="noreferrer">Code example</a> from Reddit user <strong>@ferferga</strong> shows how to use TypeScript classes with private modifiers, getters, setters (no <em>.value</em>) and first class type support as composable stores (which would be impossible with Pinia). Using TS classes here might not be a good practice but demonstrates flexibility and power of the Composition API.</p><p>Also here is a lifehack for Devtools from user <strong>@coolcosmos</strong>: <em>I just use refs. The cons is you lose the Devtools but in dev mode I import all my refs and pass them to pinia so I have all the pros and no cons.</em></p></details><details class="details custom-block"><summary>How to split logic between component and composable functions?</summary><p>It is convenient to think of it as <a href="https://en.wikipedia.org/wiki/Model-view-controller" target="_blank" rel="noreferrer">MVC pattern</a>, where the role of <code>View</code> (and partially <code>Controller</code>) is played by components, which are mainly responsible for visualization, and the logic and model (<code>Model</code> and partially <code>Controller</code>) fall on composable functions and their reactive state.</p><p>To understand what to put in a composable and what to put in a component (which may consist of several components), imagine that you change the component to another one - displaying your data in some other way. Ideally, the model (composite) should remain the same, you are only rewriting the component that has logic responsible for displaying it.</p><p>At the same time, the logic (<code>Controller</code>) can be shared between the component and the composable. For example, validation of form data can happen in the component (checking that the field is populated), in the component using a third-party utility (checking that the password is &quot;complex&quot;), and in the composable (checking that username is unique)</p></details>',7),i=[n];function r(l,c,d,h,p,m){return t(),o("div",null,i)}const b=e(s,[["render",r]]);export{f as __pageData,b as default};
