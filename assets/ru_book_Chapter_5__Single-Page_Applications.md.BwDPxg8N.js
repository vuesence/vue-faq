import{_ as s,o as i,c as a,a4 as t}from"./chunks/framework.B8KxSsRZ.js";const n="/assets/Figure_5.01_B18602.CxFklVTK.jpg",p="/assets/Figure_5.02_B18602.DCixZ9eX.jpg",h="/assets/Figure_5.03_B18602.BzEXJ6zo.jpg",e="/assets/Figure_5.04_B18602.CoBRQSxy.jpg",l="/assets/Figure_5.05_B18602.DqYwnYye.jpg",k="/assets/Figure_5.06_B18602.CTZn3hwt.jpg",r="/assets/Figure_5.07_B18602.Cto6XFmp.jpg",o="/assets/Figure_5.08_B18602.DVLiKG2s.jpg",v=JSON.parse('{"title":"Одностраничные приложения","description":"Учебник по Vue.js 3","frontmatter":{"pageClass":"textbook","head":[["meta",{"name":"og:site_name","content":"Vue.js 3 - Шаблоны проектирования и лучшие практики"}],["meta",{"name":"description","content":"Учебник по Vue.js 3"}],["meta",{"name":"og:image","content":"/images/book-face.jpg"}],["meta",{"name":"twitter:image","content":"/images/book-face.jpg"}]]},"headers":[],"relativePath":"ru/book/Chapter_5__Single-Page_Applications.md","filePath":"ru/book/Chapter_5__Single-Page_Applications.md","lastUpdated":1728438031000}'),E={name:"ru/book/Chapter_5__Single-Page_Applications.md"},g=t('<h1 id="одностраничные-приложения" tabindex="-1">Одностраничные приложения <a class="header-anchor" href="#одностраничные-приложения" aria-label="Permalink to &quot;Одностраничные приложения&quot;">​</a></h1><p>В этой главе мы продолжаем совершенствовать свои навыки работы с Vue 3, знакомясь с <strong>одностраничными приложениями</strong> (<strong>SPA</strong>). Мы узнаем, что отличает их от обычных сайтов, и рассмотрим их ключевые характеристики.</p><p>Чтобы применить полученные знания на практике, мы создадим новую версию приложения To-Do с использованием маршрутизатора Vue Router и иной схемы взаимодействия, чем в предыдущих главах. Мы также изучим методы аутентификации на примерах кода.</p><p>К концу этой главы вы будете знать следующее:</p><ul><li>Как создавать SPA с помощью Vue 3</li><li>Как организовать приложение для использования Vue Router с различными стратегиями маршрутизации</li><li>Как переделать наше приложение To-Do с практическим применением различных паттернов</li><li>Как реализовать различные паттерны аутентификации в SPA</li></ul><p>Если предыдущая глава была несколько перегружена фундаментальными знаниями, то теперь мы больше сосредоточимся на практических вопросах. В связи с этим вам потребуется доступ к приложениям-примерам, чтобы разобраться с ними.</p><h2 id="технические-требования" tabindex="-1">Технические требования <a class="header-anchor" href="#технические-требования" aria-label="Permalink to &quot;Технические требования&quot;">​</a></h2><p>Код этой главы можно найти на GitHub по адресу <a href="https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter05" target="_blank" rel="noreferrer">https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter05</a>.</p><p>Посмотрите следующее <a href="https://packt.link/RnAyz" target="_blank" rel="noreferrer">видео</a>, чтобы увидеть код в действии.</p><h2 id="что-такое-spa" tabindex="-1">Что такое SPA? <a class="header-anchor" href="#что-такое-spa" aria-label="Permalink to &quot;Что такое SPA?&quot;">​</a></h2><p>Чтобы объяснить, что такое SPA, необходимо сначала объяснить, как мы взаимодействуем с <strong>World Wide Web</strong> (<strong>WWW</strong> или <strong>W3</strong>). Когда мы вводим адрес в веб-браузере, то получаем веб-страницу, отправленную веб-сервером. В самом общем виде веб-сайт представляет собой набор страниц, в основном так называемых &quot;статических страниц&quot;.</p><p>Статические в данном контексте означают, что сервер отправляет одни и те же файлы без изменений. Это делает сайт очень быстрым и безопасным. Однако чисто статический сайт не обеспечивает большой интерактивности для конечного пользователя. Иногда это называют <strong>Web 1.0</strong>.</p><p>Серверные и браузерные скрипты позволили решить это ограничение и породили <strong>многостраничные приложения</strong> (<strong>MPA</strong>). Теперь страницы могли быть как статическими, так и динамически генерируемыми на сервере, который, в свою очередь, также мог получать вызовы новых страниц с дополнительными данными, обрабатывать их и возвращать в ответ новую страницу.</p><p>Эти новые страницы, &quot;генерируемые на лету&quot;, получили название <strong>динамических</strong> и сделали возможным появление приложений. Благодаря этим технологиям стало возможным распространение блогов, сервисов и предприятий.</p><p>С появлением таких ключевых технологий, как асинхронные коммуникации (<strong>AJAX</strong>), более развитый JavaScript, методологии локального хранения данных, увеличение скорости сети и вычислительной мощности, мы пришли к тому, что называется <strong>Web 2.0</strong>. Теперь можно было загрузить в браузер один файл и с помощью JavaScript взять под контроль весь интерфейс и интерактивность, создавая насыщенные интерактивные приложения без генерации новых страниц на сервере.</p><p>SPA обращается к серверу только для загрузки данных, пользовательского интерфейса и т.д. по мере необходимости. Появилась возможность переносить на веб-технологии то, что было традиционными десктопными приложениями, такими как текстовые редакторы, электронные таблицы, почтовые клиенты, пакеты графического дизайна и т.д.</p><p>Хорошими примерами SPA являются <em>Office 365</em>, <em>Google Docs</em>, <em>Photoshop online</em>, <em>Telegram</em>, <em>Discord</em>, <em>Netflix</em>, <em>YouTube</em> и т.д. Важно отметить, что появление SPA не отменяет использование MPA и не делает их устаревшими - каждый из них полезен в определенных контекстах. Большинство блогов и новостных сайтов сегодня, по сути, являются MPA и по-прежнему составляют значительную часть Интернета.</p><p>Наиболее сложные веб-приложения сегодня включают в себя смесь MPA и SPA, работающих вместе. SPA могут даже устанавливаться как гибридные приложения на настольных и мобильных устройствах. Как это реализовать, мы увидим в главе 6, <em>Прогрессивные Web-приложения</em>.</p><p>Двигаясь вперёд, с развитием распределенных и децентрализованных вычислений, умных блокчейнов, технология, составляющая одностраничные веб-приложения (SPA), приобрела ещё большую актуальность. Хотя эта новая эра в развитии веб-технологий еще не полностью укоренилась, ее называют <strong>Web 3.0</strong>. В этой главе мы рассмотрим эту тему более подробно и на примерах.</p><p>Все приложения, которые мы делали до сих пор, относятся к категории SPA, даже если мы еще не использовали весь их потенциал. Vue 3 специально предназначен для создания приложений такого типа и является одной из наиболее актуальных технологий для такого подхода, наряду с <em>React</em>, <em>Angular</em>, <em>Svelte</em> и другими.</p><p>Но не все так радужно и сладко. Как и в любой другой технологии, в использовании SPA есть свои компромиссы. В следующей таблице мы перечислим некоторые из них:</p><table><thead><tr><th><strong>Преимущества</strong></th><th><strong>Недостатки</strong></th></tr></thead><tbody><tr><td>- Более быстрая и эффективная загрузка<br>- Локальное кэширование для повышения производительности<br>- Разнообразные пользовательские интерфейсы и интерактивность<br>- Проще в разработке и тестировании, чем MPA<br>- Более эффективное использование кода и шаблонов, с меньшим количеством сетевых взаимодействий (по сравнению с перезагрузкой всей страницы)<br>- Высокая производительность.</td><td>- Затруднение индексации и обнаружения поисковыми системами<br>- Увеличение сложности<br>- Увеличение времени загрузки и замедление времени появления первых интерактивных элементов</td></tr></tbody></table><p>Таблица 5.1 - Преимущества и компромиссы для SPA.</p><p>Как видите, список преимуществ намного важнее, чем недостатков. Использование SPA следует рассматривать в тех случаях, когда приложение требует значительной интерактивности пользователя и обратной связи в реальном времени.</p><p>Теперь, когда мы лучше представляем себе, что такое SPA, давайте рассмотрим ключевую концепцию, лежащую в основе их функциональности: <strong>маршрутизатор</strong> приложения.</p><h2 id="vue-3-роутер" tabindex="-1">Vue 3 роутер <a class="header-anchor" href="#vue-3-роутер" aria-label="Permalink to &quot;Vue 3 роутер&quot;">​</a></h2><p>Vue - отличный фреймворк для создания SPA, но без маршрутизатора (роутера) эта задача вскоре стала бы довольно сложной. Vue router - это официальный плагин, который берет на себя навигацию по приложению и сопоставляет URL с компонентом. Это дает нам преимущества MPA. С помощью маршрутизатора мы можем сделать следующее:</p><ul><li>Создавать динамические маршруты к компонентам и управлять ими, при необходимости автоматически отображая параметры к пропсам</li><li>Идентифицировать маршруты (адреса и компоненты) по имени и использовать навигацию в коде</li><li>Динамическая загрузка компонентов при необходимости, что позволяет уменьшить размер пакета</li><li>Создать естественный и логичный подход к навигации по сайту и разделению кода</li><li>Управлять навигацией с помощью известных событий, до и после того, как навигация произошла</li><li>Создание анимации перехода между страницами таким образом, который невозможен при использовании MPA</li></ul><p>Реализация маршрутизатора Vue 3 проста и соответствует той же методологии, что и в случае с другими компонентами экосистемы. Давайте возьмем наш проект из главы 4, <em>Композиция пользовательского интерфейса с компонентами</em>, и модифицируем его для использования маршрутизатора Vue.</p><h3 id="установка" tabindex="-1">Установка <a class="header-anchor" href="#установка" aria-label="Permalink to &quot;Установка&quot;">​</a></h3><p>При запуске нового проекта вы могли заметить, что в меню программы установки есть возможность установить маршрутизатор Vue. Если вы не выбрали эту опцию, как мы сделали в нашем примере, то последующая установка достаточно проста. В терминале, в каталоге проекта, просто выполните следующую команду:</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> install</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> vue-router@4</span></span></code></pre></div><p>Команда загрузит и установит зависимости, как и для любого другого пакета в каталог <code>node_modules</code>. Для того чтобы использовать его в нашем приложении, необходимо выполнить следующие действия:</p><ol><li>Создать наши маршруты.</li><li>Связать маршруты с нашими компонентами.</li><li>Включить роутер в наше приложение.</li><li>Установите наши шаблоны, в которых маршрутизатор будет отображать наши компоненты.</li></ol><p>Как и многие другие компоненты фреймворка, маршрутизатор не указывает, в каких директориях или организациях должны быть размещены ваши маршруты или компоненты. Однако существует соглашение, которое мы будем использовать и которое стало стандартом де-факто в отрасли. В папке <code>/src</code> создайте следующие каталоги:</p><ul><li><code>/router</code> (или <code>/routes</code>): Здесь будут находиться наши JavaScript-файлы с маршрутами для нашего приложения</li><li><code>/views</code>: В этой папке будут находиться компоненты верхнего уровня, соответствующие навигации приложения (в качестве лучшей практики)</li></ul><p>После создания этих каталогов мы готовы приступить к модификации нашего приложения для включения навигации по маршруту. Но прежде давайте рассмотрим, чего мы хотим добиться с помощью нашего маршрутизатора.</p><h3 id="новое-приложение-to-do" tabindex="-1">Новое приложение To-Do <a class="header-anchor" href="#новое-приложение-to-do" aria-label="Permalink to &quot;Новое приложение To-Do&quot;">​</a></h3><p>В нашем новом приложении будут повторно использоваться компоненты для отображения списка дел, но также будет предусмотрена возможность создания нескольких списков или проектов. Мы будем отображать боковую панель со всеми нашими проектами, и при их выборе список будет обновляться.</p><p>Эти проекты также будут сохраняться в браузере, чтобы мы могли вернуться к ним позже, с помощью <code>localStorage</code>. В результате мы получим очень простую навигацию с двумя страницами верхнего уровня (компонентами):</p><ul><li>Лэндинг страница, на которой мы можем создавать новые проекты</li><li>Страница проекта, на которой мы можем работать со списком дел</li></ul><p>Следуя этим простым предпосылкам, наше приложение в готовом виде будет выглядеть следующим образом:</p><p><img src="'+n+'" alt="image"></p><p>Рисунок 5.1 - Наша лэндинг страница</p><p>Как видно на <em>Рисунке 5.1</em>, целевая страница является также местом, где мы можем создавать новые проекты. Для сбора пользовательского ввода мы, как и раньше, используем модальные диалоги.</p><p>На боковой панели отображается ссылка на страницу <strong>Home</strong> (целевая страница) и список с названиями различных проектов, которые мы создали. При щелчке на каждом из них маршрут в браузере (URL) будет обновляться, как и страница, и мы увидим нечто подобное этому:</p><p><img src="'+p+`" alt="image"></p><p>Рисунок 5.2 - Страница проекта To-Do</p><p>Последний скриншот вы можете узнать, поскольку именно его отображает наш компонент <strong>ToDoProject.vue</strong>. Собственно говоря, для достижения этого результата потребуется совсем немного модификаций. А пока давайте начнем с маршрутов.</p><h3 id="определение-маршрутов-и-объект-router" tabindex="-1">Определение маршрутов и объект Router <a class="header-anchor" href="#определение-маршрутов-и-объект-router" aria-label="Permalink to &quot;Определение маршрутов и объект Router&quot;">​</a></h3><p>Чтобы создать маршруты для нашего проекта, необходимо сначала определить их в собственном модуле. В каталоге <strong>/router</strong> создайте файл <strong>index.js</strong> со следующим содержимым:</p><h4 id="src-router-index-js" tabindex="-1">/src/router/index.js <a class="header-anchor" href="#src-router-index-js" aria-label="Permalink to &quot;/src/router/index.js&quot;">​</a></h4><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {createRouter,createWebHashHistory} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;vue-router&#39;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        //1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Landing </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;../views/Landing.vue&quot;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                          //2</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> routes</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    {path: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;landing&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, component: Landing},</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    {path: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/project/:id&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;project&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">             import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;../views/ToDoProject.vue&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),                    </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//3</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        props: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}],</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">router</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createRouter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({                                             </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//4</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    history: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createWebHashHistory</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(),                                </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//5</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    routes,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    scrollBehavior</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">to</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">savedPosition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{top:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> router;</span></span></code></pre></div><p>Начнем наш файл с импорта двух конструкторов из пакета <strong>vue-router</strong>, в строке <strong>//1</strong>:</p><ul><li><strong>createRouter</strong>, который создаст объект router, который мы можем внедрить в наше приложение в качестве плагина</li><li><strong>createWebHashHistory</strong>, который является конструктором, который мы передадим нашему объекту router, и указывает, как он будет управлять перезаписью URL в браузере</li></ul><p><strong>Web hash history</strong> будет отображать <strong>#</strong> (знак &quot;решетки&quot;) в URL и указывать, что вся навигация указывает на один файл. Все навигационные и URL-параметры будут следовать этому знаку. Это самый простой метод, не требующий специальной настройки. Однако есть и другие доступные методы: <strong>Web history</strong> (также известный как <em>HTML5 mode</em> или <em>pretty URLs</em>) и <strong>Memory</strong>.</p><p>Web history не использует хэш-нотацию, но требует специальной конфигурации сервера. Как это сделать, мы рассмотрим на примерах в главе 10, <em>Развертывание приложения</em>. Режим Memory не изменяет URL и используется в основном для веб-представлений (как в гибридных фреймворках, таких как NW.js, Electron, Tauri, Cordova, Capacitor и т.д.) и <strong>серверного рендеринга SSR</strong>). Пока мы остановимся на методе <strong>Web hash history</strong>.</p><p>В строке <strong>//2</strong> мы импортируем компонент, используя нотацию static, и определяем массив <strong>routes</strong> с нашими маршрутами. Каждый маршрут представлен объектом, содержащим как минимум следующие поля:</p><ul><li><strong>path</strong>: Строка, представляющая URL, связанный с компонентом</li><li><strong>name</strong>: Строка, которая ведет себя как уникальный идентификатор маршрута и которую мы можем вызывать программно</li><li><strong>component</strong>: Компонент, который будет отрисовываться</li></ul><p>Обратите внимание, что в строке <strong>//2</strong> мы импортируем статический компонент, а в строке <strong>//3</strong> используем нотацию динамического импорта. Это означает, что первый маршрут (с именем <strong>&quot;landing&quot;</strong>) будет включен в основной пакет, а второй маршрут (в строке <strong>//3</strong> с именем <strong>&quot;project&quot;</strong>) будет загружен только при первой необходимости, из отдельного пакета.</p><p>Используя маршруты, мы можем создать стратегию, позволяющую улучшить загрузку приложения и уменьшить размер пакета.</p><p>И наконец, в строке <strong>//4</strong> мы создаем наш объект <strong>router</strong>, используя конструктор и передавая объект options. Обратите внимание на то, что в строке <strong>//5</strong> мы передаем поле <strong>history</strong> конструктору для выбранного нами метода <strong>history</strong>.</p><p>Мы также передаем наши маршруты (очевидно), а также в качестве примера создаем одну из возможных <em>навигационных защит (navigation guards)</em>, чтобы убедиться, что после перехода по каждому маршруту окно прокручивается до самого верха. Без этого мы можем столкнуться со странным побочным эффектом, когда прокрутка не будет меняться между &quot;<em>страницами</em>&quot;.</p><p>Navigation guards срабатывают до и после навигационного события. Они могут использоваться во множестве ситуаций, например, для контроля аутентификации или предварительной загрузки данных. Полный список guards с примерами приведен в <a href="https://router.vuejs.org/guide/advanced/navigation-guards.html" target="_blank" rel="noreferrer">официальной документации</a>.</p><p>Во втором маршруте мы также включили в обозначение пути вариант с включением именованного параметра, перед которым ставится двоеточие (<strong>:id</strong>). Этот маршрут будет соответствовать всему, что следует за <strong>/project/</strong>, и присваивать его реактивной переменной, к которой мы можем обращаться программно (как это работает, мы увидим позже).</p><p>Маршрут также имеет дополнительное поле, <strong>props: true</strong>. Оно указывает на то, что параметр, названный в маршруте, будет автоматически передан компоненту в качестве пропса, если компонент определил пропс с таким же именем. Это станет полезным и очевидным в следующих разделах.</p><p>После того как маршруты и маршрутизатор определены, пришло время импортировать их в файл <strong>main.js</strong> и подключить к нашему приложению. Теперь файл будет выглядеть следующим образом:</p><h4 id="src-main-js" tabindex="-1">/src/main.js <a class="header-anchor" href="#src-main-js" aria-label="Permalink to &quot;/src/main.js&quot;">​</a></h4><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { createApp } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;vue&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> router </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;./router&quot;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> App </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./App.vue&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Modals </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;./plugins/modals&quot;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> styles </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;./assets/styles.css&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createApp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(App).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">use</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(router).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">use</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Modals).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;#app&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Достаточно просто. Теперь необходимо создать компоненты, которых сейчас нет, и адаптировать те, которые есть. Прежде чем приступить к работе с кодом, давайте посмотрим, какие новые компоненты маршрутизатор предоставляет нашему приложению.</p><h3 id="шаблонные-компоненты-маршрутизатора" tabindex="-1">Шаблонные компоненты маршрутизатора <a class="header-anchor" href="#шаблонные-компоненты-маршрутизатора" aria-label="Permalink to &quot;Шаблонные компоненты маршрутизатора&quot;">​</a></h3><p>Когда мы включаем роутер в приложение, он инжектирует в глобальную область видимости следующие новые компоненты:</p><ul><li><strong>RouterView</strong>: Этот компонент предоставляет место, где будут отображаться компоненты маршрута.</li><li><strong>RouterLink</strong>: Обеспечивает простой способ привязки к маршрутам; с помощью удобных пропсов и стилей мы можем контролировать внешний вид и конечный элемент рендеринга.</li></ul><p>Вместе с определением роутера и маршрутов эти два компонента в нашем шаблоне позволяют предложить навигацию и лучше организовать наш код. Прежде чем разбираться с ними, давайте посмотрим, как они работают в нашем приложении. Начнем модифицировать наш компонент <strong>App.vue</strong>, чтобы превратить его в контейнер макета (стили опущены):</p><h3 id="app-vue" tabindex="-1">App.vue <a class="header-anchor" href="#app-vue" aria-label="Permalink to &quot;App.vue&quot;">​</a></h3><div class="language-vue vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setup</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Sidebar </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./components/Sidebar/Sidebar.vue&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;app&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Sidebar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Sidebar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">router-view</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">router-view</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>Как видите, мы включаем новый компонент <strong>Sidebar</strong>, который будет содержать основную навигацию нашего приложения. Затем мы помещаем единственный компонент <code>&lt;router-view&gt;</code>, в котором наш маршрутизатор будет отображать каждую страницу. Что касается стилей, то за подробностями я отсылаю к коду на GitHub.</p><p>Теперь пришло время создать компонент <strong>Sidebar</strong> по пути <strong>/src/components/Sidebar/Sidebar.vue</strong> и скопировать код из репозитория. В этом небольшом файле есть на что посмотреть. Начнем разбираться с шаблона и с того, как мы используем экземпляры <strong>RouterLink</strong>. Первый из них статичен и указывает на целевую страницу. Вместо того чтобы просто использовать ссылку или тег <code>&lt;a&gt;</code>, мы определяем цель ссылки как объект, в котором напрямую ссылаемся на имя маршрута:</p><div class="language-vue vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">RouterLink</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> :</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">to</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;landing&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;w3-padding&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> active-class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;w3-yellow&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;Home&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">RouterLink</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>По умолчанию при выводе этого компонента он становится тегом <code>&lt;a&gt;</code>, а атрибут <strong>href</strong> динамически преобразуется в соответствующий маршрут. Если мы изменим определение маршрута и зададим ему другой путь, это никак не повлияет на данный код.</p><p>Хорошей практикой является обращение к маршрутам по их именам, а не по их URL. В случае, если нам необходимо передать в URL параметры строки запроса, мы можем легко сделать это, передав в качестве атрибута <strong>params</strong> объект с парами ключ/значение. Вот пример:</p><div class="language-vue vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">RouterLink</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> :</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">to</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;search&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">params</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:{</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">text</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;abc&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}}</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;Search&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">RouterLink</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>Предшествующий атрибут <strong>params</strong> будет отображен как URI со строкой запроса <strong>?text=abc</strong>.</p><p>Как мы уже говорили, если у маршрута активен атрибут <strong>props</strong> и принимающий компонент определил одноименный prop, то значение будет присвоено автоматически. Именно такая ситуация позволяет нам сформировать список ссылок и передать на страницу нашего проекта идентификатор каждого проекта, что можно увидеть далее в файле:</p><div class="language-vue vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> v-for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">p </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> _projects</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> :</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">p.id</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;RouterLink :to=&quot;{name:&#39;project&#39;,params:{id:p.id}}&quot;&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         {{p.name}}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;/RouterLink&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>При создании проекта на лэндинг странице каждому из них автоматически присваивается уникальный идентификатор, который мы используем в предыдущем коде. Как и в случае с другими пропсами, мы можем следить за изменениями и реагировать на них, загружая соответствующие пункты To-Do для каждого проекта.</p><p>Исходя из этого, мы модифицировали файл <strong>ToDoProject.vue</strong>, чтобы определить пропс (тип определять не нужно):</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$props </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> defineProps</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;id&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">])</span></span></code></pre></div><p>Также мы установливаем <code>watch</code> для обнаружения изменений с помощью этих строк в <strong>script</strong> разделе:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { watch } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;vue&quot;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">watch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $props.id, loadProject)</span></span></code></pre></div><p>Этот watch получает функцию, которая возвращает атрибут <strong>prop</strong>, а затем запускает функцию <strong>loadProject()</strong>. На этом этапе вы можете спросить, зачем нам это нужно, ведь каждый URL-адрес отличается. Ответ заключается в том, что Vue и router загружают компонент только в первый раз, когда он нужен. До тех пор, пока он остается в поле зрения, он не перезагружается и только обновляет реактивные свойства. Поскольку наш код <code>script setup</code> выполняется только при первой загрузке, в момент создания, нам нужен способ обнаружения изменений для выполнения нереактивных операций, таких как загрузка пунктов To-Do для проекта из <strong>localStorage</strong>.</p><p>Остальные изменения можно посмотреть в репозитории. В компонентах, работающих со списком дел, меняется очень мало, в этом и заключается смысл инкапсуляции. Даже модификация <strong>ToDoProject.vue</strong> невелика.</p><p>Однако есть одно дизайнерское решение, на которое следует обратить внимание: использование модели <em>pub/sub</em> для синхронизации меню боковой панели.</p><p>Мы создали синглтон с шиной событий (<strong>eventBus</strong>). Когда мы создаем новый проект или удаляем его, мы вызываем событие обновления с помощью следующей строки:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">eventBus.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">emit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;#UpdateProjects&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Мы регистрируем прослушивание событий в тех компонентах, которым это необходимо, во время события <em>монтирования</em> жизненного цикла компонента, и снимаем его с регистрации перед <em>размонтированием</em>. В нашем случае он нужен только в компоненте <strong>Sidebar</strong>, но при необходимости его можно разместить в любом месте нашего приложения:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onMounted</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     eventBus.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">on</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;#UpdateProjects&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, updateProjects)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onBeforeUnmount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    eventBus.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">off</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;#UpdateProjects&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, updateProjects)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><p>Имя события тривиально и не подчиняется никаким соглашениям. В этой книге мы добавляем к нему &quot;решетку&quot;, как личное предпочтение.</p><p>В предыдущих реализациях, а также в компоненте <strong>ToDoProject.vue</strong>, мы использовали родителя в качестве канала для обмена информацией между компонентами-братьями, о чем мы говорили ранее. Здесь мы используем другую модель, паттерн <em>pub/sub</em>, чтобы не загрязнять компонент <strong>App.vue</strong> подобной задачей.</p><p>В главе 7, <em>Управление потоком данных</em>, мы рассмотрим другие подходы к централизованному управлению состоянием. Теперь рассмотрим более подробные примеры и детали использования маршрутизатора в более продвинутых сценариях.</p><h3 id="вложенные-маршруты-именованные-представления-и-программная-навигация" tabindex="-1">Вложенные маршруты, именованные представления и программная навигация <a class="header-anchor" href="#вложенные-маршруты-именованные-представления-и-программная-навигация" aria-label="Permalink to &quot;Вложенные маршруты, именованные представления и программная навигация&quot;">​</a></h3><p>До сих пор мы создавали статические и динамические маршруты, даже с некоторыми параметрами в адресе. Но маршрутизатор может делать даже больше. Используя именованные маршруты, мы можем также создавать &quot;подмаршруты&quot; и именованные &quot;sub-view&quot; для создания более глубоких навигационных деревьев и сложных макетов.</p><p>Начнем с примера. Предположим, у нас есть трехуровневая структура данных, и мы хотим реактивно представить ее пользователю таким образом, чтобы он мог выбрать один уровень, а затем &quot;спуститься&quot; к деталям. Мы также хотим, чтобы это отражалось в URL-адресе, чтобы можно было поделиться или сослаться на полный текст дела. В данном случае уровнями будут страна, штат и город. В этом случае пользовательский интерфейс будет выглядеть следующим образом:</p><p><img src="`+h+`" alt="image"></p><p>Рисунок 5.3 - Выборка с использованием нескольких именованных представлений (view) и подмаршрутов</p><p>Как видно из скриншота, при выборе пользователем страны заполняется список штатов и обновляется URL. При выборе штата обновляется список городов, и, наконец, при выборе города информация появляется в последнем столбце.</p><p>Возможно, вы уже встречали такой способ навигации. Существует множество способов его реализации, одни из которых более эффективны, чем другие. Мы хотим реализовать это в качестве учебного упражнения, поэтому начнем с определения маршрутов. Вот фрагмент массива определения наших маршрутов:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/directory&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;directory&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;../views/Directory.vue&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    children</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        { </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            path: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;:country&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;states&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, props: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;../views/State.vue&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            children:[</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                { </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                    path:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;:state&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;cities&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, props: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">                    component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;../views/City.vue&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                }  </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            ]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        } </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ] </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="определение-вложенных-маршрутов" tabindex="-1">Определение вложенных маршрутов <a class="header-anchor" href="#определение-вложенных-маршрутов" aria-label="Permalink to &quot;Определение вложенных маршрутов&quot;">​</a></h4><p>На первый взгляд, мало что изменилось, кроме включения в маршрут нового атрибута: <strong>children[]</strong>. Этот атрибут получает массив маршрутов, которые, в свою очередь, могут иметь другие дочерние маршруты, как мы видим в предыдущем фрагменте кода.</p><p>Дочерние маршруты будут отображаться в компоненте <strong>RouteView</strong> своих родителей, а их пути будут конкатенированы с путями родителей, если только они не начинаются с корня (с обратной косой черты).</p><p>Для навигации по маршруту, который будет отображаться в родительском компоненте <strong>RouteView</strong>, необходимо использовать атрибут <strong>RouteView</strong>.</p><p>Для перехода к каждому маршруту мы можем использовать любой из методов, распознаваемых маршрутизатором. Однако хорошей практикой является использование их имен и передача любого параметра или строки запроса через объект, и пусть маршрутизатор разрешает URL.</p><p>В качестве примера посмотрим, как в компоненте <strong>Directory.vue</strong> мы используем элемент <strong>RouterLink</strong>:</p><h4 id="src-views-directory-vue-component-lines-13-18" tabindex="-1">/src/views/Directory.vue component, lines 13-18 <a class="header-anchor" href="#src-views-directory-vue-component-lines-13-18" aria-label="Permalink to &quot;/src/views/Directory.vue component, lines 13-18&quot;">​</a></h4><div class="language-vue vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> v-for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> countries</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> :</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">c.code</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;RouterLink</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        :to=&quot;{name:&#39;states&#39;, params:{country:c.code}}&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        active-class=&quot;selected&quot;&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        {{c.name}}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;/RouterLink&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>Мы включили наш компонент <strong>RouterLink</strong> внутрь цикла, чтобы создать столько ссылок, сколько необходимо на основе наших данных. Целью ссылки является объект, в который мы передаем имя маршрута (<strong>states</strong>), а также передаем параметры, соответствующие определению маршрута и пропса компонента.</p><p>Обратите внимание, что путь компонента определен как параметр (он начинается с двоеточия - <strong>:country</strong>), и он также соответствует props-определению объекта в <strong>State.vue</strong>. Именно это соответствие позволяет маршрутизатору автоматически передавать нам данные.</p><p>Проанализировав код, можно заметить, что в самом маленьком дочернем компоненте, файле <strong>City.vue</strong>, мы определяем в реквизите и страну, и государство. Однако в определении маршрута появляется только один параметр - state (<strong>:state</strong>).</p><p>Тем не менее, запустив пример, можно заметить, что этот пропс также заполнен. Это происходит потому, что дочерние компоненты наследуют вместе с URL-путем все параметры, определенные в маршруте родительского компонента. В данном случае наш компонент также получает параметр <strong>:country</strong>, который был передан родителю, даже если он не отображается в его конкретном маршруте.</p><p>Запустив приложение, вы увидите нечто похожее на этот снимок экрана:</p><p><img src="`+e+`" alt="image"></p><p>Рисунок 5.4 - Пример вложенных маршрутов, с выделениями.</p><p>Для простоты из статических файлов были включены только две страны. В реальном проекте эти данные будут получены из базы данных.</p><p>До сих пор мы использовали компоненты <strong>RouteView</strong> &quot;по умолчанию&quot;, но маршрутизатор Vue позволяет включать несколько представлений в один компонент, присваивая им разные имена. Здесь мы рассмотрим только обозначения, поскольку реализация тривиальна. Рассмотрим компонент со следующим шаблоном:</p><div class="language-vue vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;RouterView name=&quot;header&quot;&gt;&lt;/RouterView&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;RouterView name=&quot;sidebar&quot;&gt;&lt;/RouterView&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;RouterView&gt;&lt;/RouterView&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>В предыдущем коде мы присваиваем нашим маршрутам идентификацию с помощью атрибута <strong>name</strong>. У нас также есть представление (view) без имени, в этом случае оно считается представлением &quot;по умолчанию&quot;, или с именем <strong>default</strong>.</p><p>Для использования этой новой схемы немного меняется определение маршрутов. Теперь в каждом определении у нас нет атрибута <strong>component</strong>, а вместо него есть атрибут <strong>components</strong> (во множественном числе), который ожидает объект. Имя каждого поля в объекте должно совпадать с именами, заданными нашим компонентам <strong>RouterView</strong>, и быть равным объекту.</p><p>Для предыдущего фрагмента кода эквивалентное определение маршрута будет выглядеть следующим образом:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{ </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/layout&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;main&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    components</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;...&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),.</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        header</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;...&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), .</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        sidebar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;...&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}}</span></span></code></pre></div><p>Используя этот тип определения, мы можем создавать сложные макеты, поскольку можем также определить подмаршруты, которые будут использовать, например, заголовок и боковую панель из родительского блока и будут отображаться только в представлении по умолчанию. У нас есть впечатляющее количество возможностей для создания динамических пользовательских интерфейсов.</p><p>Одна из важных тем, которую мы должны затронуть, прежде чем перейти к следующему разделу, - это программная навигация. До сих пор мы использовали новые компоненты, предоставляемые маршрутизатором, но мы также можем запускать навигацию непосредственно из нашего JavaScript, не полагаясь на то, что пользователь вызовет событие.</p><p>Для этого Vue Router предоставляет нам два удобных конструктора, которые можно использовать в сценариях наших компонентов: <strong>useRoute</strong> и <strong>useRouter</strong>. Мы импортируем эти конструкторы в наши компоненты с помощью следующего кода:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { useRoute, useRouter } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;vue-router&quot;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">   $route</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useRoute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(),</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        $router</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useRouter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Как вы понимаете, <strong>$route</strong> предоставляет нам информацию о текущем маршруте, а <strong>$router</strong> позволяет изменять и запускать навигационные события.</p><p>Объект <strong>$router</strong> предоставляет несколько методов, наиболее часто используемые из которых перечислены ниже:</p><h3 id="push" tabindex="-1"><strong>.push()</strong> <a class="header-anchor" href="#push" aria-label="Permalink to &quot;**.push()**&quot;">​</a></h3><p>Самый важный метод. Он проталкивает новый URL в веб-историю и осуществляет переход к соответствующему компоненту.</p><p>Это программный эквивалент использования <strong>RouterLink</strong>. Он принимает либо строку с URL для перехода, либо объект с необязательными атрибутами. Ниже приведены примеры для каждого принимаемого параметра:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Navigate to a URL</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$router.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/my/route&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Navigate to a URL, using an object</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$router.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({path: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/my/route&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Navigate to a route, with parameters</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$router.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    name:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;route-name&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    params:{key:value}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Navigate to a route, with query strings</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$router.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    name:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;route-name&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    query:{key:value}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><h3 id="replace" tabindex="-1"><strong>.replace()</strong> <a class="header-anchor" href="#replace" aria-label="Permalink to &quot;**.replace()**&quot;">​</a></h3><p>Заменяет текущий компонент навигации, не изменяя URL. Принимает те же параметры, что и <code>.push</code></p><h3 id="go" tabindex="-1"><strong>.go()</strong> <a class="header-anchor" href="#go" aria-label="Permalink to &quot;**.go()**&quot;">​</a></h3><p>Этот метод получает в качестве параметра целое число и запускает навигацию по истории браузера. Положительные числа ведут вперед, а отрицательные - назад по истории навигации.</p><p>Чаще всего он используется для реализации ссылки &quot;назад&quot; в приложении. Вот несколько примеров:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Go back one entry</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$router.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">go</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Go forward one entry</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$router.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">go</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Как уже говорилось, это наиболее часто используемые методы, которые необходимо иметь в наличии. Могу сказать, что их использование позволяет решить подавляющее большинство регулярных задач.</p><p>Полный список доступных методов можно найти в официальной документации, они позволяют справиться и с возникающими крайними случаями. Рекомендую ознакомиться с ними, хотя бы для того, чтобы знать о них, по адресу <a href="https://router.vuejs.org/api/interfaces/Router.html#properties" target="_blank" rel="noreferrer">https://router.vuejs.org/api/interfaces/Router.html#properties</a>.</p><p>К таким случаям можно отнести: динамическое добавление и удаление маршрутов (<strong>.addRoute()</strong> и <strong>.removeRoute()</strong>), получение зарегистрированных маршрутов (<strong>.getRoutes()</strong>), проверка наличия маршрута перед переходом к нему (<strong>.hasRoute()</strong>) и т.д. Мы не будем их использовать, поэтому подробно рассматривать их здесь нецелесообразно.</p><p>Напротив, объект <strong>$route</strong> предоставляет нам информацию о текущем пути (URL), по которому происходит рендеринг нашего компонента. Как и в предыдущем примере, здесь приведен список наиболее часто используемых атрибутов и их назначение:</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><strong>Атрибуты</strong></td><td><strong>Описание</strong></td></tr><tr><td><strong>.name</strong></td><td>Возвращает текущее имя маршрута.</td></tr><tr><td><strong>.params</strong></td><td>Возвращает объект с параметрами, указанными в пути (URL). Если они были сопоставлены с пропсами, то значения могут пересекаться.</td></tr><tr><td><strong>.query</strong></td><td>Возвращает объект с декодированной строкой запроса, привязанной к текущему пути.</td></tr><tr><td><strong>.hash</strong></td><td>Если таковые имеются, то возвращается путь в URL, следующий за знаком хэша (<strong>#</strong> ).</td></tr><tr><td><strong>.fullPath</strong></td><td>Возвращает строку с полным путем маршрута.</td></tr></tbody></table><p>В примерах этой книги мы неоднократно будем использовать <strong>.name()</strong>, <strong>.params()</strong> и <strong>.query()</strong>, поскольку они, как правило, являются наиболее часто используемыми. Полный список методов и свойств можно найти в официальной документации.</p><div class="tip custom-block"><p class="custom-block-title">Важные различия в обозначениях</p><p>Мы использовали конструкторы <strong>useRoute</strong> и <strong>useRouter</strong> в Composition API с нотацией <code>script setup</code>. В Options API нет необходимости инициализировать эти объекты. Оба они доступны автоматически через <strong>this.$route</strong> и <strong>this.$router</strong>. Также объекты <strong>$route</strong> и <strong>$router</strong> автоматически доступны в шаблоне при использовании Composition API.</p></div><p>Полный пример кода можно найти в репозитории GitHub, в разделе <strong>Глава 5/Вложенные маршруты</strong>, по <a href="https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/chapter05" target="_blank" rel="noreferrer">этому адресу</a>.</p><p>Теперь, когда мы знаем, как работать с маршрутами, параметрами и строками запросов, пришло время рассмотреть некоторые общие шаблоны аутентификации в SPA, поскольку для многих из них необходимы различные пути (URL).</p><h2 id="исследование-шаблонов-аутентификации" tabindex="-1">Исследование шаблонов аутентификации <a class="header-anchor" href="#исследование-шаблонов-аутентификации" aria-label="Permalink to &quot;Исследование шаблонов аутентификации&quot;">​</a></h2><p>Сила SPA становится очевидной, когда за ними стоит сервер, предоставляющий дополнительные сервисы. Одним из таких сервисов является аутентификация. В большинстве приложений возникает необходимость идентификации пользователей и предоставления дополнительных услуг на основе их прав, статуса, конфиденциальности, группы или любой другой категории, относящейся к контексту приложения. Ярким примером этого являются приложения веб-почты, такие как <em>Outlook</em> или <em>Gmail</em>.</p><p>Современные веб-стандарты предоставляют нам несколько возможностей для осуществления асинхронного взаимодействия с сервером. Их часто называют <strong>AJAX</strong> (<em>AJAX расшифровывается как Asynchronous JavaScript and XML</em>).</p><p>В самом базовом виде для таких сетевых взаимодействий мы могли бы использовать объект <strong>XMLHttpRequest</strong>, но новые спецификации предоставляют нам прямую функцию <strong>fetch()</strong>, которая является более удобной и стандартной для браузеров.</p><p>Хотя эти методы вполне допустимы, для других целей, кроме простых нужд, лучше использовать библиотеку, предоставляющую более широкие функциональные возможности, построенные поверх этих технологий - например, такую, которая предоставляет <strong>API</strong> для соответствия методам <strong>HTTP</strong>-запросов (<strong>GET</strong>, <strong>POST</strong>, <strong>PUT</strong>, <strong>OPTIONS</strong> и <strong>DELETE</strong>) для удобного использования <strong>RESTful API</strong> (где <strong>REST</strong> означает <strong>Representational State Transfer</strong>, тип архитектуры, используемый в сетевых коммуникациях).</p><p>Подробнее об этом мы поговорим в главе 8, <em>Многопоточность с Web Workers</em>. Пока же просто имейте в виду, что лучшим вариантом будет библиотека для обработки сетевых асинхронных взаимодействий. В нашем случае мы будем использовать замечательную библиотеку <a href="https://axios-http.com/" target="_blank" rel="noreferrer">Axios</a>, которую можно установить в свое приложение с помощью следующей команды:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$ npm install axios</span></span></code></pre></div><p>Затем в своем сервисе или компоненте вы можете импортировать и использовать библиотеку с помощью следующего кода:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> axios </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;axios&quot;</span></span></code></pre></div><p>Библиотека предоставляет методы, соответствующие каждому HTTP-запросу (<strong>.get()</strong>, <strong>.post()</strong>, <strong>.put()</strong> и т.д.), каждый из которых возвращает промис, разрешающийся в результат запроса или отклоняющий его в случае ошибки.</p><p>После этого мы готовы рассмотреть некоторые общие шаблоны для аутентификации пользователей в наших приложениях.</p><h3 id="простая-аутентификация-по-имени-пользователя-и-паролю" tabindex="-1">Простая аутентификация по имени пользователя и паролю <a class="header-anchor" href="#простая-аутентификация-по-имени-пользователя-и-паролю" aria-label="Permalink to &quot;Простая аутентификация по имени пользователя и паролю&quot;">​</a></h3><p>Это самый простой подход к аутентификации пользователей, при котором проверка учетных данных выполняется нашей реализацией на сервере. В этом случае серверный бэкенд предоставляет API для проверки набора учетных данных, собранных нашим SPA.</p><p>Традиционно учетные данные хранятся на сервере, в базе данных, а обмен данными будет осуществляться поверх <strong>Secure Sockets Layer</strong> (<strong>SSL</strong>) или шифрованного обмена, что одно и то же. Рассмотрим процесс работы графически:</p><p><img src="`+l+`" alt="image"></p><p>Рисунок 5.5 - Простая аутентификация по имени пользователя и паролю</p><p>В этом рабочем процессе происходит следующее:</p><ol><li>SPA собирает значения имени пользователя и пароля и передает их в определенную конечную точку (endpoint) нашего сервера для аутентификации.</li><li>Сервер использует информацию, хранящуюся в базе данных, для проверки имени пользователя и пароля.</li><li>Результат операции возвращается клиенту SPA в ответ на его первоначальный запрос (<em>1</em>).</li></ol><p>Хотя на рисунке 5.5 показано количество шагов, следует учитывать, что все это делается всего за один сетевой вызов и его ответ. Разработка кода проверки на сервере выходит за рамки данной книги, но код внутри нашего сервиса или компонента Vue 3 будет выглядеть примерно так:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> axios </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;axios&quot;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { ref } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;vue&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> _username</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ref</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">_password</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ref</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> doSignIn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    axios.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">post</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;https://my_server_API_URL&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         {username:_username.value,password:_password.value})</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">response</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(response.status)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(response.data)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">err</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Как видите, реализация достаточно проста и зависит от нашей собственной логики и дизайна API сервера. Важно помнить, что необходимо проверять статус ответа (все, что находится между <strong>200</strong> и <strong>299</strong>, является успехом) и данные, отправленные сервером, чтобы действовать соответствующим образом. Все коммуникации и преобразование данных за нас выполняет Axios (при условии, что наш API принимает и обрабатывает данные в формате JSON).</p><p>В случае успеха мы должны сохранить результат в состоянии нашего приложения и соответственно разрешить доступ пользователю, в основном разблокировав навигацию по закрытым или ограниченным маршрутам. Такая защита может быть реализована множеством различных способов, наиболее распространенными из которых являются использование навигационных защит (guards), создание динамических маршрутов и т.д.</p><p>Этот способ вполне допустим и широко применяется в большинстве приложений. Однако он имеет ряд недостатков:</p><ul><li>Мы отвечаем за ведение базы данных с именами пользователей и паролями (пожалуйста, в зашифрованном виде!) и реализацию логики проверки</li><li>Мы несем юридическую ответственность за обработку данных пользователей в соответствии с местным законодательством</li><li>Мы отвечаем за всю безопасность системы, от начала до конца</li><li>Пользователь должен помнить или нести ответственность за свои учетные данные</li><li>Мы должны предусмотреть способы обработки нестандартных ситуаций, а также проблем пользователей и поиска учетных данных</li></ul><p>Эти недостатки ни в коем случае не являются сдерживающим фактором, но являются важными моментами, которые следует иметь в виду, если мы пойдем этим путем. Так или иначе, большинство приложений должны иметь способ аутентификации пользователей, который зависит от их собственной логики и реализации, поскольку не все наши пользователи (в зависимости от контекста) будут готовы использовать другую форму аутентификации, как мы увидим далее.</p><h3 id="openid-и-сторонняя-аутентификация" tabindex="-1">OpenID и сторонняя аутентификация <a class="header-anchor" href="#openid-и-сторонняя-аутентификация" aria-label="Permalink to &quot;OpenID и сторонняя аутентификация&quot;">​</a></h3><p>Помимо вопросов безопасности, основной проблемой при аутентификации является то, как легко эти учетные данные могут быть утеряны или неправильно использованы конечным пользователем. Это случается с каждым из нас. Чем больше сервисов мы используем в Интернете, тем большее количество учетных данных пользователю необходимо &quot;помнить&quot;.</p><p>Существует множество различных методов решения этой проблемы, позволяющих снизить нагрузку на пользователя, связанную с запоминанием всех этих имен и паролей. Одним из таких стандартов является протокол <strong><a href="https://openid.net/" target="_blank" rel="noreferrer">OpenID</a></strong>.</p><p>Протокол OpenID обеспечивает аутентификацию пользователей без необходимости обмена учетными данными (именами пользователей и паролями) между сайтами. Он основан на работе протокола <strong>OAuth 2.0</strong>, который используется для безопасного обмена информацией и ресурсами без необходимости использования паролей.</p><p>Это достигается путем обмена токенами между различными участниками процесса. Стандартом для таких коммуникаций является использование <strong>JSON Web Tokens</strong> (<strong>JWTs</strong>). Давайте рассмотрим каждый из этих терминов немного подробнее, чтобы лучше понять, как работает этот протокол.</p><p>JWT - это строка, содержащая три секции, разделенные точкой (<strong>.</strong>) и закодированные в Base64. Затем каждая секция кодирует JSON-объект со следующей информацией:</p><ul><li><strong>Header</strong>: содержит криптографическую информацию, используемую для кодирования токена, такую как алгоритм, тип токена (обычно <strong>JWT</strong>), а в некоторых случаях даже тип данных, представленных в полезной нагрузке.</li><li><strong>Payload</strong>: этот объект содержит информацию, которую мы хотим (должны) передать, и в основном имеет &quot;свободный формат&quot;, то есть может содержать любую пару <strong>key:value</strong> по мере необходимости. Однако есть несколько четко определенных полей, которые также могут быть использованы, например &quot;<strong>iat</strong>&quot; (<strong>Issued At Time</strong>), в котором содержится временная метка создания токена. Самое главное, этот объект должен содержать уникальный идентификатор пользователя (поле &quot;<strong>sub</strong>&quot;, для субъекта).</li><li><strong>Signature</strong>: Подпись представляет собой строку, образованную путем конкатенации зашифрованных строковых представлений заголовка и полезной нагрузки, выраженных в Base64. Для шифрования используется секретный ключ (пароль), известный только аутентифицирующему серверу и серверу сайта.</li></ul><p>Получив токен, сайт в рабочем процессе декодирует и проверяет его с помощью секретного ключа, используя тот же метод, что и эмитент. Если подписи не совпадают, то считается, что токен испорчен или скомпрометирован, и он отклоняется. JWT может быть перехвачен и декодирован третьей стороной, поэтому этот метод действует как дополнительное средство защиты от подделки. Рассмотрим пример создания токена:</p><ul><li><strong>Header</strong>: <strong>{&quot;alg&quot;: &quot;HS256&quot;, &quot;typ&quot;: &quot;JWT&quot;}</strong>. Здесь мы используем алгоритм <strong>HS256</strong> и объявляем используемый тип как <strong>JWT</strong>.</li><li><strong>Payload</strong>: <strong>{&quot;sub&quot;:&quot;1234567890&quot;,&quot;name&quot;:&quot;Pablo</strong> <strong>D. Garaguso&quot;, &quot;iat&quot;:</strong> <strong>1516239022}</strong>.</li><li><strong>Secret encryption key</strong>: <strong>секретный ключ</strong>.</li></ul><p>Поле подписи создается по такой формуле (при условии, что у нас есть функция, шифрующая текст по алгоритму HS256):</p><p><strong>HMACSHA256(base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), &quot;secret key&quot;)</strong></p><p>И наконец, полученные строки в кодировке Base64 снова конкатенируются, в результате чего мы получаем вполне работоспособный токен. Также обратите внимание на то, что каждая секция (Header, Payload и Signature) разделяется точкой (<strong>.</strong>):</p><p><strong>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IlBhYmxvIEQuIEdhcmFndXNvIiwiaWF0IjoxNTE2MjM5MDIyfQ.mPr551xpsCgmIzp8EZuSCoy7t7iQNpp_iGzIR14E_Jo</strong></p><p>Для проверки этого токена можно воспользоваться таким сервисом, как <a href="https://jwt-decoder.com/" target="_blank" rel="noreferrer">https://jwt-decoder.com/</a>. Однако для его проверки необходимо использовать секретный ключ. Проверить его можно на сайте <a href="https://jwt.io/" target="_blank" rel="noreferrer">https://jwt.io</a>, где также можно найти дополнительную информацию об этом стандарте.</p><p>В протоколе OpenID JWT используются для передачи и проверки информации между сторонами, поэтому так важно хорошо понимать эту концепцию. Существует несколько рабочих процессов, поддерживаемых протоколом. Давайте рассмотрим упрощенное представление <strong>потока кода авторизации</strong> (<a href="https://openid.net/specs/openid-connect-core-1_0.html" target="_blank" rel="noreferrer">https://openid.net/specs/openid-connect-core-1_0.html</a>) протокола со всеми участниками, а затем посмотрим, какие части нам нужно реализовать в наших Vue 3 SPA:</p><p><img src="`+k+`" alt="image"></p><p>Рисунок 5.6 - Поток кода авторизации OpenID во всей его красе.</p><p>Как видите, для реализации этого рабочего процесса нам необходимы три участника: 1) наш SPA, обрабатывающий множество маршрутов, 2) сервер аутентификации <strong>service provider</strong> (<strong>SP</strong>) и 3) наш собственный backend-сервер. Можно выполнить аутентификацию и проверку без бэкенда, в браузере, тогда потребуется только два участника, но это не рекомендуется, так как раскрывается секретный ключ в нашем JavaScript.</p><p>Однако такая возможность существует для встроенных приложений, например мобильных, где пользователь не имеет свободного доступа к коду страницы (в гибридных приложениях).</p><p>Для реализации рабочего процесса клиент (наше приложение) должен зарегистрироваться в службе аутентификации. Процесс зависит от каждой сущности, но в результате у нас будет зарегистрировано следующее:</p><ul><li>Идентификационная строка <strong>client_id</strong>, уникальная для нашего приложения.</li><li>Значение <strong>secret_key</strong>, которое будет известно только серверу аутентификации и нашему внутреннему приложению. Оно будет использоваться для кодирования и подписи наших токенов.</li><li>Серия <em>конечных точек (endpoints)</em> в сервере аутентификации и в нашем приложении, куда будет перенаправляться пользователь на каждом шаге. Соответствующий обмен токенами будет осуществляться при этих перенаправлениях как часть строки запроса в URL.</li></ul><p>Итак, давайте рассмотрим эти шаги в деталях, а также то, как их реализовать в нашем приложении на Vue 3:</p><h3 id="_1" tabindex="-1">1. <a class="header-anchor" href="#_1" aria-label="Permalink to &quot;1.&quot;">​</a></h3><p>Пользователю необходимо пройти аутентификацию, поэтому мы перенаправляем его на конечную точку, указанную нам сервером аутентификации. Строка запроса должна содержать следующие (обязательные) поля:</p><ul><li><strong>scope</strong>: <strong>openid</strong></li><li><strong>response_type</strong>: <strong>код</strong></li><li><strong>client_id</strong>: Идентификатор клиента, выданный сервером аутентификации</li><li><strong>redirect_uri</strong>: Тот самый адрес, который мы зарегистрировали на сервере, куда будет перенаправлен пользователь после успешной аутентификации</li><li><strong>state</strong>: Любые данные или состояние приложения, которые мы хотим получить в ответ после аутентификации</li></ul><p>Для подготовки URL перенаправления мы сначала создаем объект с указанными выше полями и значениями, а также используем <strong>URLSearchParams</strong> для создания строки запроса (см. <a href="https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams" target="_blank" rel="noreferrer">https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams</a>):</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> query_data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {scope: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;openid&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">},</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">query_string</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> URLSearchParams</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(query_data).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Следующим шагом мы можем использовать объект location для выполнения перенаправления:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">location.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">assign</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;https://auth_endpoint&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;?&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> query_string)</span></span></code></pre></div><h3 id="_2" tabindex="-1">2. <a class="header-anchor" href="#_2" aria-label="Permalink to &quot;2.&quot;">​</a></h3><p>При успешной аутентификации сервер аутентификации перенаправит пользователя на конечную точку, которую мы зарегистрировали в качестве получателя. Передаваемые параметры запроса будут зависеть от результата операции:</p><ul><li>Успешный вход в систему: <ul><li><strong>code</strong>: <strong>code_token</strong>, который в дальнейшем необходимо обменять на <strong>identity_token</strong>.</li><li><strong>state</strong>: Любые данные, которые мы отправили на сервер и хотим получить обратно. Мы можем использовать это для перенаправления пользователя внутри нашего приложения, например.</li></ul></li><li>Неудачный вход в систему: <ul><li><strong>error</strong>: Код ошибки, определенный протоколом (<strong>interaction_required</strong>, <strong>invalid_request_uri</strong>, и так далее).</li></ul></li></ul><p>Переадресация вызовет загрузку нашего приложения, и маршрутизатор отрендерит указанный нами компонент. В настройках нашего скрипта нам необходимо перехватить переданную нам строку запроса, чтобы затем использовать ее в следующем шаге. Сделать это без использования сторонних библиотек можно с помощью следующего кода:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { useRoute } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;vue-router&quot;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> $route</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useRoute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ($route.query.error){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // Аутентификация не удалась, примите меры</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Аутентификация прошла успешно, сделайте что-нибудь</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   sendToServer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">($route.query.code)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="_3" tabindex="-1">3. <a class="header-anchor" href="#_3" aria-label="Permalink to &quot;3.&quot;">​</a></h3><p>На этом шаге мы просто отправляем полученный код на бэкенд, что означает реализацию функции <strong>sendToServer()</strong>, о которой говорилось ранее. Поскольку теперь мы имеем дело с нашей собственной реализацией, способ сделать это тривиален. В данном примере мы используем Axios:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{ axios }</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;axios&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sendToServer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">code</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    axios</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">post</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;URL нашего сервера&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, {код})</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">result</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         // Устанавливаем токен в наши заголовки</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        axios.defaults.headers.common </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">          &quot;Authorization&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Bearer &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result.data.identity_token</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Обработка ошибки</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>В предыдущем примере мы отправили на сервер строку <strong>code_token</strong> и получили от него в качестве ответа строку <em>identity_token</em>*. Затем мы делаем еще один шаг вперед и устанавливаем в заголовках по умолчанию для нашего приложения стандартный заголовок <strong>Authorization</strong> с маркером <strong>Bearer</strong>. С этого момента нашему серверу достаточно проверить заголовки и убедиться, что запрашиваемая операция принадлежит действительному пользователю.</p><p>Выполнение проверки токенов и <em>шагов 4</em> и <em>5</em> выходит за рамки данной книги, поскольку мы рассматриваем приложения на Vue 3. Как видите, та часть, которую должен обрабатывать наш SPA, довольно проста и не содержит большого количества кода (некоторые проверки ошибок для краткости были опущены).</p><p>Существует достаточно большое количество приложений, в которых используются токены.</p><p>Существует большое количество синдицированных сервисов аутентификации, как бесплатных, так и платных, которые мы можем реализовать в нашем приложении. Наиболее распространенными в наши дни являются значки, перенаправляющие пользователей на их использование, например, для входа в систему с помощью <em>Google</em>, <em>Facebook</em>, <em>Twitter</em>, <em>GitHub</em>, <em>Microsoft</em> и т.д.</p><p>Существуют также метасервисы, предоставляющие всех вышеперечисленных провайдеров внутри хорошо упакованных библиотек, например <a href="https://auth0.com/" target="_blank" rel="noreferrer">Auth0</a> (сейчас входит в состав <a href="https://www.okta.com/" target="_blank" rel="noreferrer">Okta</a>). Когда дело доходит до реализации этого рабочего процесса, мы, конечно, не испытываем недостатка в вариантах.</p><h3 id="беспарольная-аутентификация-или-аутентификация-по-одноразовому-паролю-otp" tabindex="-1">Беспарольная аутентификация или аутентификация по одноразовому паролю (OTP) <a class="header-anchor" href="#беспарольная-аутентификация-или-аутентификация-по-одноразовому-паролю-otp" aria-label="Permalink to &quot;Беспарольная аутентификация или аутентификация по одноразовому паролю (OTP)&quot;">​</a></h3><p>Другим решением, позволяющим отказаться от использования учетных данных, является беспарольный доступ. Основная идея заключается в том, чтобы полагаться на безопасность другой системы (электронная почта, мобильные тексты, приложения-аутентификаторы и т.д.) для подтверждения пользователя.</p><p>В процессе генерируется чувствительный к времени код &quot;одноразового использования&quot; и отправляется пользователю через систему поддержки через внутренний сервис. Внешний сервис (приложение) ожидает ввода права пользователем в определенный промежуток времени.</p><p>Например, распространенной реализацией является отправка бэкендом на телефон пользователя текстового сообщения с кодом, который необходимо ввести в приложении до истечения времени.</p><p>Здесь представлено визуальное представление этого рабочего процесса, учитывая, что пользователь был зарегистрирован с помощью электронной почты или номера телефона. Предполагается, что они <em>известны</em>, а значит, их принадлежность проверена:</p><p><img src="`+r+`" alt="image"></p><p>Рисунок 5.7 - Беспарольная аутентификация на основе электронной почты</p><p>В предыдущем сценарии работы обратите внимание, что код OTP не попадает в веб-приложение до тех пор, пока пользователь не введет его. Валидация происходит в бэкенде, а не во фронтенде. Это делает наше приложение очень простым, поскольку ему нужно только сначала собрать письмо и отправить его на сервер, а затем в течение заданного времени ждать нового ввода. В сервисе или компоненте, использующем Axios, этот код будет выглядеть примерно так:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> _user_email</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ref</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      _wait_seconds</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ref</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      _show_input_code</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ref</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      _otp_code</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ref</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> signInUser</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    axios.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">post</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;https://requestOTP_url&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        {email:_user_email.value})</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">result</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        _wait_seconds.value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">result.data.wait_time;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        _show_input_code.value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        startOTPtimer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     }).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">err</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> startOTPtimer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> interval_id</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setInterval</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(_wait_seconds.value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){_wait_seconds.value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">--</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">clearInterval</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(interval_id);}},</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> checkOTP</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   axios.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">post</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;https://validateOTP_URL&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,{code:_otp_code.value})</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">result</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(result.status</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">200</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result.status</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">300</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         // Пользователь подтвержден, переходим к защищенному маршруту</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         // Валидация не прошла. Перенаправление на маршрут ошибок.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">err</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>В предыдущем коде мы опустили импорты и шаблон, так как на данном этапе они должны быть тривиальными для читателя. Наш шаблон должен содержать как минимум поле для ввода email пользователя, второе поле для ввода OTP-кода, а также две кнопки для запуска по щелчку функции <strong>signInUser()</strong> и функции <strong>checkOTP()</strong>.</p><p>Первая передаст письмо на бэкенд и будет ждать ответа с указанием времени ожидания в секундах, которое мы используем для запуска таймера (всегда полезно сообщить пользователю, сколько времени у него есть для ввода кода). В настоящее время для электронных писем и текстовых сообщений стандартом является 60 секунд.</p><p>Когда это происходит, мы также скрываем первое поле, а затем показываем форму ввода &quot;OTP&quot;. Когда пользователь вводит код и нажимает <strong>Submit</strong>, активизируется функция <strong>checkOTP()</strong>, и мы снова передаем код на сервер, ожидая ответа. В случае успеха мы можем перенаправить пользователя в защищенную область в соответствии с логикой нашего приложения.</p><p>Учитывая тривиальность шаблона, для читателя будет хорошим упражнением самостоятельно создать компонент и шаблон. Затем возможное решение можно найти в примерах кода в папке <a href="https://learning.oreilly.com/library/view/vue-js-3-design/9781803238074/B18602_05.xhtml#_idTextAnchor130" target="_blank" rel="noreferrer">Глава 5</a>.</p><p>Следуя прогрессивному подходу к безопасности, следующим шагом является объединение предыдущих подходов в общий новый процесс: <strong>двухфакторная аутентификация</strong> (<strong>2FA</strong>), которую мы сейчас и рассмотрим.</p><h3 id="_2fa-двухфакторная-аутентификация" tabindex="-1">2FA - двухфакторная аутентификация <a class="header-anchor" href="#_2fa-двухфакторная-аутентификация" aria-label="Permalink to &quot;2FA - двухфакторная аутентификация&quot;">​</a></h3><p>В случае 2FA наше приложение объединяет два или более предыдущих подхода для проверки пользователя. Ключевая концепция этого метода заключается в том, что даже третьего лица или простого имени пользователя и пароля недостаточно, и пользователю необходимо иметь &quot;вторичный фактор&quot; для проверки - например, использование зарегистрированной электронной почты, номера телефона (для отправки кодов по SMS), приложений для аутентификации (например, Google Authenticator), USB-устройства, карты безопасности (с чипом или считывателем полос) и т.д.</p><p>Процесс работы прост, но требует от нашего бэкенда больше, чем от фронтенд-приложения. После того как SPA аутентифицирует пользователя с помощью любого из перечисленных ранее методов, на бэкенде запускается второй запрос для отправки соответствующего запроса на устройство безопасности. Предположим, что пользователь получает от нашего сервера SMS с кодом. Наш SPA будет ждать, собирать этот код в течение определенного промежутка времени (обычно 60 секунд) и отправлять его на бэкенд в определенную конечную точку. Именно сервер затем проверяет код.</p><p>В реальности это похоже на наличие двух или нескольких паролей, проверка которых производится каскадно. Если какой-либо шаг окажется неудачным, то вся операция будет отменена.</p><p>Вот визуализация этого процесса:</p><p><img src="`+o+`" alt="image"></p><p>Рисунок 5.8 - Упрощенный вид взаимодействия SPA и сервера с 2FA.</p><p>Как видно из упрощенного рабочего процесса, процесс проверки пользователя с помощью 2FA (как и в случае с беспарольными и OTP-методами) зависит не столько от кода или специфической криптографии, сколько от использования продуманных средств коммуникации и изоляции данных. Данные и процесс проверки никогда не покидают наш сервер и не могут быть видны конечному пользователю, даже если открыть код нашего SPA. В некотором смысле этот рабочий процесс можно представить как объединение аутентификации по OpenID или учетным данным с последующей реализацией OTP.</p><p>Основная задача нашего приложения - собирать данные, составляющие каждый шаг, и передавать их на сервер. В промежутках между ними мы могли бы менять маршрут или обновлять интерфейс, но эта реализация тривиальна, поэтому конкретного кода мы здесь не увидим (как программно изменить маршрут, например, можно было посмотреть ранее).</p><p>В целом 2FA считается &quot;более безопасным методом&quot;, но он не лишен недостатков и может подойти не для всех приложений. Например, что произойдет, если вы знаете свое имя пользователя и пароль, но потеряете второе устройство (мобильный украдут, взломают и т.д.)? Организации, использующие этот метод, часто предоставляют возможность восстановления идентификационных данных, нередко с дорогостоящей реализацией (вспомните банк и телефонную службу). В итоге этот метод создает еще один уровень сложности в аутентификации пользователей, а вместе с ним и еще одну возможную точку отказа, что при неправильном подходе приводит к разочарованию пользователей.</p><p>Далее рассмотрим еще один метод аутентификации, который набирает обороты в качестве нового ребенка в блоке шаблонов аутентификации: Web3-аутентификация.</p><h3 id="web3-аутентификация" tabindex="-1">Web3-аутентификация <a class="header-anchor" href="#web3-аутентификация" aria-label="Permalink to &quot;Web3-аутентификация&quot;">​</a></h3><p>Перед тем как перейти к рассмотрению этой темы, необходимо определить, что такое <strong>Web3</strong>. По всей видимости, существует некоторая путаница в определении, поэтому для наших целей Web3 считается следующей итерацией или эволюцией Интернета, где вычислительная мощность будет осуществляться на децентрализованных и распределенных серверах с использованием технологий блокчейн.</p><p>Наиболее известными и популярными приложениями этих технологий в настоящее время являются криптовалюты, децентрализованные самоуправляемые организации, децентрализованные финансы, игры типа &quot;играй и получай&quot;, распределенные облачные хранилища и многое другое.</p><p>Блокчейн (англ. <strong>blockchain</strong>) - это бухгалтерская книга, которая ведется сетью распределенных компьютеров. Все, что записывается в неё, является неизменяемым и общедоступным для любого пользователя сети. Некоторые блокчейны являются &quot;умными&quot;, то есть они могут содержать не только данные, но и запускать приложения, как и любой бэкэнд-сервис.</p><p>Фронтенд-приложения, подключаемые к блокчейну, называются <strong>распределенными приложениями (DApps</strong>), которые в большинстве своем являются <em>SPA</em>. Для решения этой задачи, как мы уже убедились, очень хорошо подходит фреймворк Vue 3. DApp должен соединяться с внутренним сервером, который является частью целевой сети блокчейна. Такие серверы называются <strong>узлами (nodes)</strong>.</p><p>В некоторых случаях DApp может взаимодействовать непосредственно с блокчейном. Большинство, если не все, блокчейны используют криптовалюты для регулирования операций и вознаграждения узлов, поддерживающих сеть. Криптовалюты логически приписываются к уникальному идентификатору блокчейна, называемому &quot;кошельком&quot;.</p><p>В этих кошельках реализованы весьма интеллектуальные криптографические технологии, позволяющие подтверждать друг друга при выполнении операций с помощью открытых и закрытых ключей. У пользователя может быть множество кошельков. В блокчейне не существует электронной почты или способов восстановления утерянных ключей, и каждый кошелек уникален.</p><p>Для того чтобы решить все эти проблемы с криптографическими знаками и валидацией, а также упростить работу пользователей, существуют специальные плагины для браузеров, называемые &quot;цифровыми кошельками&quot;, а также мобильные приложения-кошельки, которые также реализуют просмотр веб-страниц.</p><p>Эти приложения хранят учетные данные и выполняют всю работу с блокчейном. Конечно, существует множество библиотек для выполнения тех же задач на чистом JavaScript, но это выходит за рамки данной книги. Далее мы рассмотрим, как в нашем SPA мы можем использовать возможности этих технологий для идентификации пользователя даже автоматически при посещении страницы нашего приложения.</p><p>Мы сосредоточимся на том, как сделать так, чтобы пользователь мог идентифицировать свою личность.</p><p>В качестве примера мы рассмотрим крупнейший смарт-блокчейн - сеть Ethereum. Аналогичный рабочий процесс с большим или меньшим количеством шагов применим и к другим сетям, использующим различные SDK, поэтому перенос или включение дополнительных блокчейнов не слишком далеко отстоит от наших примеров. Основной концептуальный рабочий процесс выглядит следующим образом:</p><p>Импортируем библиотеку для подключения к сети на нашем JavaScript, либо через такие библиотеки, как <a href="https://www.npmjs.com/package/web3" target="_blank" rel="noreferrer">web3js</a>, <a href="https://www.npmjs.com/package/ethjs" target="_blank" rel="noreferrer">ethjs</a>, либо использовать тот, который инжектируется непосредственно кошельком браузера - в нашем примере, <strong>MetaMask</strong>, в <strong>window.ethereum</strong>.</p><ul><li>Используя объект <strong>ethereum</strong>, мы запрашиваем у пользователя подключение его кошелька к нашему сайту и получаем адрес выбранного кошелька</li><li>После этого наше приложение может отправить на бэкэнд идентификатор кошелька (который является публичным) и использовать его в качестве уникального идентификатора учетной записи пользователя</li></ul><p>Как уже было сказано, мы будем использовать объект, инжектированный <a href="https://metamask.io/" target="_blank" rel="noreferrer">MetaMask</a>, поскольку это один из наиболее известных браузерных кошельков. В данном случае здесь приведен код, запрашивающий кошелек текущего пользователя:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ethereum</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">request</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ method: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;eth_requestAccounts&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">    result</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(result[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]),</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">    err</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(err)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Вот и все! Выделенная строка побуждает <em>MetaMask</em> открыть новое окно и запросить у пользователя разрешение на подключение его кошелька к вашему веб-приложению, а затем вернуть удобный промис. В случае разрешения результатом будет массив строк, в котором первой позицией будет адрес кошелька для текущей сети. В случае отказа будет выдана ошибка.</p><div class="tip custom-block"><p class="custom-block-title">Совет</p><p>При использовании MetaMask можно открыть в браузере <strong>Инструменты разработчика</strong> и набрать в одной строке приведенный ниже код для его тестирования.</p></div><p>С помощью <strong>MetaMask</strong> тот же код для сети <strong>Ethereum</strong> также работает при подключении к сетям <strong>Polygon</strong> и <strong>Binance Smart Chain</strong> (три по цене одного!). Другие сети и кошельки, например кошелек Phantom, работают по тому же принципу и внедряют в объект <strong>windows</strong> новый объект <strong>.solana</strong>. Ознакомьтесь с документацией по целевому блокчейну, чтобы узнать подробности каждой реализации.</p><p>Взаимодействие с каждым блокчейном и его кодом выходит за рамки данной книги, поэтому мы ограничимся идентификацией пользователя по адресу его кошелька. Получив эту идентификацию, логика приложения должна сохранить ее для дальнейшего использования, поскольку она действует как идентификатор пользователя.</p><p>Для аутентификации и взаимодействия с несколькими блокчейнами существуют также решения сторонних разработчиков, и нам следует рассмотреть их, прежде чем реализовывать собственное решение.</p><h2 id="подведение-итогов" tabindex="-1">Подведение итогов <a class="header-anchor" href="#подведение-итогов" aria-label="Permalink to &quot;Подведение итогов&quot;">​</a></h2><p>В этой главе мы значительно улучшили наше приложение и создали продуманный SPA с навигацией с помощью маршрутизатора Vue. Это важная концепция, позволяющая сегментировать приложение и организовать работу между членами команды разработчиков. Фракционирование приложения по пути навигации упрощает разработку и сопровождение и делает их более организованными.</p><p>Мы также изучили несколько стандартных паттернов аутентификации, которые можно использовать в наших приложениях. Они охватывают большое количество сценариев, используемых сегодня в индустрии, начиная от самых простых имени пользователя и пароля и заканчивая новыми Web3 DApps.</p><p>Мы также уделили время тому, как работают стандартные протоколы, такие как OAuth, а также OTP, и как они могут быть реализованы для дополнительного уровня безопасности в качестве второго фактора аутентификации. Все эти навыки актуальны и необходимы для современных стандартов веб-приложений.</p><p>В следующей главе мы познакомимся с <strong>прогрессивными веб-приложениями (PWAs)</strong>.</p><h2 id="вопросы-для-проверки" tabindex="-1">Вопросы для проверки <a class="header-anchor" href="#вопросы-для-проверки" aria-label="Permalink to &quot;Вопросы для проверки&quot;">​</a></h2><p>В этой главе мы рассмотрели множество различных тем и ввели новые понятия. Используйте следующие вопросы, чтобы закрепить полученные знания:</p><ul><li>Когда лучше использовать SPA вместо MPA и наоборот?</li><li>Каковы преимущества использования маршрутизатора в SPA? Назовите не менее трех из собственного анализа.</li><li>Как можно использовать представления для определения компоновки приложения?</li><li>Как можно получить доступ к параметрам и строке запроса, переданным маршруту, в JavaScript?</li><li>Каковы некоторые общие стандартные шаблоны для аутентификации пользователей?</li><li>Каковы некоторые соображения безопасности при аутентификации пользователей в SPA?</li></ul>`,275),d=[g];function y(u,c,F,m,C,A){return i(),a("div",null,d)}const q=s(E,[["render",y]]);export{v as __pageData,q as default};
