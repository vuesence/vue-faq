import{_ as n,o as p,c as l,k as i,a as s,t as e,R as a}from"./chunks/framework.WpHw1xpL.js";const h="/assets/Figure_1.01_B18602.CWBkZpEz.jpg",V=JSON.parse('{"title":"Фреймворк Vue 3","description":"Учебник по Vue.js 3","frontmatter":{"head":[["meta",{"name":"og:site_name","content":"Vue.js 3 - Шаблоны проектирования и лучшие практики"}],["meta",{"name":"description","content":"Учебник по Vue.js 3"}],["meta",{"name":"og:image","content":"/images/book-face.jpg"}],["meta",{"name":"twitter:image","content":"/images/book-face.jpg"}]]},"headers":[],"relativePath":"ru/book/Chapter_1__The_Vue_3_Framework.md","filePath":"ru/book/Chapter_1__The_Vue_3_Framework.md","lastUpdated":1704136635000}'),k={name:"ru/book/Chapter_1__The_Vue_3_Framework.md"},r=a(`<h1 id="фреимворк-vue-3" tabindex="-1">Фреймворк Vue 3 <a class="header-anchor" href="#фреимворк-vue-3" aria-label="Permalink to &quot;Фреймворк Vue 3&quot;">​</a></h1><p>Современная всемирная паутина (World Wide Web) претерпела значительные изменения по сравнению с теми временами, когда Интернет представлял собой лишь набор связанных между собой страниц, предназначенных для академических и научных целей. По мере развития технологий и увеличения мощности машин к прежним протоколам добавлялись все новые и новые возможности, конкурировали новые методы и технологии, пока, наконец, не были приняты стандарты. Дополнительные возможности появились в виде плагинов для браузера и встроенного контента. Распространенными были Java-апплеты, Flash, Macromedia, Quicktime и другие плагины. Именно с появлением HTML5 большинство из них, если не все, были постепенно вытеснены стандартами.</p><p>Сегодня существует четкое различие между структурой, стилем и поведением. <strong>Язык разметки гипертекста</strong> (<strong>HTML</strong>) определяет структурные элементы, из которых состоит веб-страница. <strong>Каскадные таблицы стилей</strong> (<strong>CSS</strong>) предоставляют правила, изменяющие внешний вид HTML-элементов, включая даже анимацию и трансформацию. И, наконец, JavaScript - язык программирования, который обеспечивает поведение и может обращаться и изменять как HTML, так и CSS. Такое количество различных возможностей также привело к высокой <em>сложности</em> и несовместимости между браузерами. Именно здесь и зародились библиотеки и фреймворки, которые сначала решали проблемы несовместимости и стандартизации внешнего вида, но вскоре стали включать в себя и другие парадигмы программирования, выходящие за рамки простого манипулирования HTML и CSS.</p><p>Некоторые из наиболее популярных сегодня библиотек и фреймворков используют <strong>реактивную парадигму</strong>. Они умело вносят изменения в JavaScript, которые автоматически отражаются в HTML/CSS. Vue 3 - это последняя версия прогрессивного фреймворка, в котором в значительной степени используется концепция реактивности. В нем также реализованы другие парадигмы и паттерны проектирования программного обеспечения, позволяющие создавать все: от простых взаимодействий на статичной веб-странице до сложных приложений, которые могут даже устанавливаться локально и конкурировать с нативными настольными приложениями.</p><p>В этой книге мы познакомимся с фреймворком Vue 3 и изучим различные шаблоны проектирования, которые помогут нам создавать первоклассные приложения: от простых веб-страниц до мощных <strong>прогрессивных веб-приложений</strong> (<strong>PWA</strong>). Попутно мы рассмотрим лучшие практики и хорошо зарекомендовавшие себя паттерны в программной инженерии.</p><p>В этой главе рассматриваются следующие темы:</p><ul><li>Прогрессивный фреймворк</li><li>Однофайловые компоненты</li><li>Различные варианты синтаксиса для написания компонентов</li></ul><p>К концу этой главы вы будете иметь базовое представление о том, какое место Vue 3 занимает в ландшафте JavaScript и какие возможности он предоставляет. Для пользователей Vue 2 в этой книге есть приложение, в котором описаны изменения, на которые необходимо обратить внимание при переносе приложения. По мере продвижения по книге мы будем наращивать знания на основе этих концепций.</p><h2 id="прогрессивныи-фреимворк" tabindex="-1">Прогрессивный фреймворк <a class="header-anchor" href="#прогрессивныи-фреимворк" aria-label="Permalink to &quot;Прогрессивный фреймворк&quot;">​</a></h2><p>Перед тем как рассказать о том, что представляет собой Vue, необходимо провести различие между терминами <em>библиотека</em> и <em>фреймворк</em>. Они часто используются как взаимозаменяемые, но разница между ними есть, и хороший разработчик должен знать об этом, выбирая тот или иной вариант для создания веб-приложения.</p><p>Выбирая тот или иной вариант для создания веб-приложения, мы должны понимать, что это такое.</p><p>Давайте рассмотрим определения этих терминов:</p><ul><li><strong>Библиотека</strong> - это коллекция многократно используемого кода в виде функций, классов и т.д., который был разработан кем-то другим и может быть легко импортирован в вашу программу. Они не предписывают, как и где их использовать, но обычно предоставляют документацию по их применению. Программист сам решает, когда и как их применять. Эта концепция существует в большинстве языков разработки, вплоть до того, что некоторые из них полностью основаны на понятии импорта библиотек для обеспечения функциональности.</li><li>В <strong>фреймворке</strong> также есть наборы классов и функций для использования, но в нем прописаны спецификации, определяющие, как должна работать программа, с какой архитектурой, в каких условиях может быть использован ваш код. Ключевой атрибут, на который следует обратить внимание, заключается в том, что фреймворк инвертирует управление в приложении, то есть определяет поток программы и данных. Тем самым он подчеркивает структуры или стандарты, которых должен придерживаться программист.</li></ul><p>Разделив понятия, теперь возникает вопрос, когда использовать библиотеку, а когда фреймворк. Прежде чем ответить на этот вопрос, давайте поймем, что при создании реальных приложений между ними существует огромная &quot;серая зона&quot;. Теоретически одно и то же приложение можно построить, используя любой из этих двух вариантов. Как и всегда в программной инженерии, необходимо определиться с компромиссами для каждого подхода. Так что воспринимайте то, что будет написано дальше, с щепоткой соли; это не закон, написанный на камне:</p><ul><li>Вы можете использовать <em>библиотеку</em> при создании приложений малого и среднего размера или при необходимости добавления дополнительной функциональности в приложение (в общем случае, вы можете использовать дополнительные библиотеки внутри фреймворков). Существуют и исключения из правила &quot;размера&quot;. Например, <strong>React</strong> - это библиотека, но на ее основе построены огромные приложения, такие как Facebook. Компромисс заключается в том, что использование только библиотек без фреймворка потребует выработки общих подходов и большей координации внутри команды, поэтому усилия по управлению и руководству могут значительно возрасти. С другой стороны, библиотека, используемая в рамках обычного программирования на JavaScript, может предложить некоторые важные улучшения производительности и обеспечить значительную гибкость.</li><li>Вы можете захотеть использовать <em>фреймворк</em> при создании приложений среднего и большого размера, когда вам нужна структура, помогающая координировать разработку, или когда вы хотите быстро начать, минуя &quot;азы&quot; разработки общей функциональности с нуля. Существуют фреймворки, построенные поверх других фреймворков, например, <strong>Nuxt</strong> построен поверх <strong>Vue</strong>. Компромисс заключается в том, что для построения приложения вам предписывается архитектурная модель, которая часто соответствует определенному подходу и образу мышления. Вам и вашей команде придется изучить фреймворк и его ограничения и жить в этих границах. Всегда есть вероятность того, что в будущем ваше приложение может перерасти рамки. В то же время некоторые из преимуществ таковы: более легкая координация работы, значительный выигрыш от стартового рывка, верное и проверенное решение общих проблем, ориентация на конкретные ситуации (например, торговые приложения в сравнении с социальными сетями) и многое другое. Однако в зависимости от фреймворка вы можете столкнуться с небольшим снижением производительности за счет дополнительной обработки данных или трудностями масштабирования. Вам предстоит взвесить компромиссы в каждом конкретном случае.</li></ul><p>Итак, что же такое Vue? По определению, <em>Vue - это прогрессивный фреймворк</em> для создания пользовательских интерфейсов. Прогрессивность означает, что он обладает архитектурными преимуществами фреймворка, а также скоростью и модульными преимуществами библиотеки, поскольку функции и функциональность могут быть реализованы постепенно. На практике это означает, что Vue предписывает определенные модели построения приложения, но в то же время позволяет начинать с малого и расширять его настолько, насколько это необходимо. Вы даже можете использовать несколько приложений Vue на одной странице или взять на себя все приложение. При необходимости можно даже импортировать и использовать другие библиотеки и фреймворки. Весьма причудливо!</p><p>Еще одной фундаментальной концепцией Vue является <strong>реактивность</strong>. Она подразумевает возможность автоматического отображения в HTML значения или изменений, внесенных в переменную в JavaScript, а также внутри вашего кода. В этом заключается большая часть волшебства, предлагаемого Vue.</p><p>В традиционном программировании, когда переменной присваивается значение, оно сохраняется до тех пор, пока не будет программно изменено. Однако в реактивном программировании, если значение переменной зависит от других переменных, то при изменении одной из этих зависимостей переменная примет новое результирующее значение. Возьмем, к примеру, следующую простую формулу:</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">A</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> B</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> +</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> C</span></span></code></pre></div><p>В реактивном программировании каждый раз, когда <strong>B</strong> или <strong>C</strong> меняют значение, изменяется и <strong>A</strong>. Как вы увидите далее в этой книге, это очень мощная модель для построения пользовательских интерфейсов. В данном примере, в соответствии с терминологией, <strong>A</strong> - это зависимое, а <strong>B</strong> и <strong>C</strong> - зависимости.</p><p>В следующих главах мы будем изучать этот <em>прогрессивный</em> атрибут в процессе создания примеров приложений. Но перед этим нам нужно посмотреть, что предлагает Vue 3 в самом базовом виде.</p><h2 id="использование-vue-в-веб-приложении" tabindex="-1">Использование Vue в веб-приложении <a class="header-anchor" href="#использование-vue-в-веб-приложении" aria-label="Permalink to &quot;Использование Vue в веб-приложении&quot;">​</a></h2><p>Существует несколько вариантов использования Vue в веб-приложении, и это во многом зависит от того, какую цель вы преследуете:</p><ul><li>Для размещения на странице небольшого автономного приложения или фрагмента кода можно напрямую импортировать Vue и код внутри тега <em>script</em></li><li>Для создания более крупного приложения вам понадобится инструмент сборки, который возьмет ваш код и <em>соберет</em> его для распространения</li></ul><p>Обратите внимание, что я использую слово <em>сборка</em>, а не <em>компиляция</em>, поскольку JavaScript-приложения интерпретируются и выполняются во время исполнения в браузере. Это станет очевидным позже, когда мы введем понятие <strong>однофайловых компонентов</strong></p><p>Давайте кратко рассмотрим пример первого случая на примере очень простой HTML-страницы:</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">html</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">head</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;         </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> src</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;https://unpkg.com/vue@3&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">head</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">body</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;app&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;{{message}}&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">createApp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Vue;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      createApp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">          return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { message: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Hello World!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;#app&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">body</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">html</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div>`,27),o=i("strong",null,"head",-1),g=i("strong",null,"script",-1),E=i("strong",null,"сети доставки контента",-1),d=i("strong",null,"CDN",-1),c=i("strong",null,"Vue",-1),u=i("strong",null,"body",-1),y=i("strong",null,"div",-1),m=i("strong",null,'id="app"',-1),v=i("strong",null,"message",-1),F=i("strong",null,"интерполяцией",-1),b=a('<p>В конце <strong>body</strong> мы создаем элемент сценария с нашим приложением. В начале мы извлекаем из Vue функцию <strong>createApp</strong> и используем ее для создания приложения, передавая объект. Этот объект имеет определенные поля, которые определяют <strong>компонент</strong>. В данном случае этот компонент раскрывает только метод <strong>data()</strong>, который, в свою очередь, возвращает объект. Имена полей в этом объекте будут рассматриваться как реактивные переменные, которые мы можем использовать как в JavaScript, так и в HTML. Наконец, конструктор <strong>createApp()</strong> возвращает экземпляр приложения Vue 3, поэтому мы передаем вызов по цепочке и вызываем метод <strong>mount()</strong>, чтобы смонтировать наше скромное приложение на элемент с идентификатором <strong>app</strong>. Обратите внимание, что в качестве аргумента мы используем CSS-селекторы (знак &quot;решётки&quot; указывает на аттрибут <strong>id</strong>, следовательно, <strong>id=&quot;app&quot;</strong> выбирает <strong>#app</strong>).</p><p>Поскольку этот метод использования Vue не так уж распространен (или популярен), мы сосредоточимся на более важных вещах и будем использовать <strong>сборщик</strong> для организации рабочего процесса и значительно лучшего опыта разработчика, но сначала нам нужно узнать немного больше о Vue и о том, что делает его таким замечательным.</p><h3 id="путь-сборщика-лучшии-путь" tabindex="-1">Путь сборщика, лучший путь... <a class="header-anchor" href="#путь-сборщика-лучшии-путь" aria-label="Permalink to &quot;Путь сборщика, лучший путь...&quot;">​</a></h3><p>Как вы можете себе представить, импортировать Vue непосредственно в веб-страницу можно только для очень маленьких приложений. Вместо этого Vue построен на концепции <em>компонентов</em>, которые представляют собой многократно используемые изолированные наборы JavaScript-кода, HTML и CSS, ведущие себя как единое целое. Их можно рассматривать как строительные блоки для создания веб-страницы. Очевидно, что браузер ничего об этом не знает, поэтому мы будем использовать <em>сборщик</em> (<em>bundler</em>) для преобразования нашего приложения в то, что браузер может интерпретировать, с дополнительным преимуществом - выполнением ряда оптимизаций в процессе. Именно здесь вступает в действие &quot;фреймворк&quot;, который предписывает, как должны быть написаны эти компоненты и какие методы должны содержать.</p><p>При использовании сборщика весь наш код будет упакован в один или несколько JavaScript-файлов, которые браузер будет загружать во время выполнения. Рабочий процесс выполнения в браузере для приложения Vue можно изобразить следующим образом:</p><p><img src="'+h+`" alt="Рисунок 1.1: Очень упрощенный вид порядка выполнения нашего приложения
при использовании сборщика"></p><p>Рисунок 1.1: Очень упрощенное представление порядка выполнения нашего приложения при использовании сборщика</p><p>Браузер, как обычно, загрузит страницу <strong>index.html</strong>, а затем загрузит и выполнит файл <strong>bundle.js</strong>, как и любой другой JavaScript. Сборщик упакует все наши файлы и выполнит их в заданном порядке:</p><ol><li>Файл <strong>main.js</strong> импортирует и запускает приложение Vue 3.</li><li>Затем начнется композиция страницы из <em>главного</em> компонента, заключенного в файл <strong>App.vue</strong>. Этот компонент порождает другие компоненты, формируя таким образом дерево компонентов, из которых состоит страница.</li></ol><p>Не волнуйтесь, если сейчас это звучит несколько странно. Мы увидим эти понятия в действии по мере создания наших примеров приложений на протяжении всей книги. В главе 3 <em>Установка рабочего проекта</em>, мы запустим простое приложение, используя такую же диаграмму.</p><p>До сих пор вы имели представление о том, что такое библиотеки и фреймворки, и лишь бегло ознакомились с тем, что предлагает Vue. Важно помнить, что в современном мире JavaScript принято использовать сборщики, которые помогают нам организовать наши приложения и оптимизировать код для браузера. В дальнейшем мы будем работать с официальным сборщиком Vue 3, <strong>Vite</strong>. Но сначала нам нужно знать еще несколько базовых понятий.</p><h2 id="понимание-однофаиловых-компонентов" tabindex="-1">Понимание однофайловых компонентов <a class="header-anchor" href="#понимание-однофаиловых-компонентов" aria-label="Permalink to &quot;Понимание однофайловых компонентов&quot;">​</a></h2><p>Как вы уже догадались, файл <strong>App.vue</strong>, упомянутый ранее, представляет собой <strong>однофайловый компонент</strong> (<strong>SFC</strong>), что является одним из главных достижений Vue. В файле этого типа мы можем описать HTML, CSS и JavaScript, определяющие компонент. Веб-страница состоит из иерархии компонентов, начиная с точки входа (традиционно называемой <strong>App.vue</strong>) и заканчивая последней настраиваемой кнопкой, если хотите. Более подробно о компонентах мы поговорим в главе 4 <em>Композиция пользовательского интерфейса с помощью компонентов</em>, а пока запомните, что это путь, предписанный фреймворком. Если у вас есть опыт работы с объектно-ориентированными языками, это может показаться вам знакомым (и вы не ошибетесь).</p><p>SFC - это обычный текстовый файл с расширением <strong>.vue</strong>, содержащий следующие секции:</p><div class="language-vue vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setup</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Here we write our JavaScript</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;      </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">h1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;Hello World! This is pure HTML&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">h1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">style</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> scoped</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">h1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  color</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">purple</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">style</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>Поначалу может показаться странным, что все это содержимое собрано в одном месте, но именно это и делает его великолепным. Вот описание каждого раздела:</p><ul><li>Тег <strong>script</strong>, который окружает наш JavaScript и, в зависимости от синтаксиса, экспортирует объект с четко определенными полями. На практике это превращается в <em>модуль</em>, который является современным способом разделения кода в JavaScript. Обратите также внимание, что мы используем атрибут-модификатор <strong>setup</strong>. Он определяет интерфейс приложения, который мы будем использовать для написания нашего кода на Vue. Мы также можем объявить атрибут <strong>lang=&quot;ts&quot;</strong>, чтобы использовать TypeScript вместо обычного JavaScript.</li><li>Тег <strong>template</strong> окружает HTML для нашего компонента. Здесь мы можем использовать элементы HTML, другие компоненты, директивы и т. д. Большим преимуществом Vue является то, что мы можем использовать обычный HTML для написания нашего HTML. Это может показаться очевидным, но другие библиотеки работают с этим совершенно иначе и имеют свой собственный синтаксис для этого. Однако Vue 3 позволяет использовать и другие синтаксисы с помощью плагинов сборщика. Здесь у нас есть опции.</li><li>Тег <strong>style</strong>, в котором мы разместим CSS для нашего компонента. В данном случае мы используем атрибут <strong>scoped</strong>, который инкапсулирует правила и ограничивает их рамками нашего компонента, тем самым предотвращая их &quot;утечку&quot; в остальное приложение. Как и в предыдущих разделах, мы также можем использовать различный синтаксис для написания стилей, если он поддерживается сборщиком.</li></ul><div class="tip custom-block"><p class="custom-block-title">Хорошая практика</p><p>Всегда используйте scoped стили, если только вы не определяете стили для родительского компонента или CSS-переменные, которые вы хотите передать всему приложению в явном виде. Для стилей, распространяющихся на все приложение, используйте отдельный CSS-файл.</p></div><p>Важно помнить, что SFC содержит эти три элемента, определяющие один компонент. Сборщик сделает свою магию, отделит каждую часть и поместит ее туда, где она должна быть, чтобы браузер мог правильно интерпретировать ее. Мы будем использовать для этого быстрый и новый <strong>Vite</strong> в главе 3 <em>Установка рабочего проекта</em>, и в главе 4 <em>Композиция пользовательского интерфейса с компонентами</em>, мы подробно рассмотрим компоненты и то, как управлять потоком программы и информацией между ними. Но сначала давайте рассмотрим, как мы пишем наши компоненты.</p><h2 id="разные-варианты-options-composition-и-script-setup-api" tabindex="-1">Разные варианты - options, composition, и script setup API <a class="header-anchor" href="#разные-варианты-options-composition-и-script-setup-api" aria-label="Permalink to &quot;Разные варианты - options, composition, и script setup API&quot;">​</a></h2><p>Классический способ описания компонента в Vue 2 получил название <em>Options API</em>. Для сохранения обратной совместимости этот же синтаксис поддерживается и в Vue 3. Однако существует и новый синтаксис, названный <em>Composition API</em>, который мы и будем использовать в этой книге.</p><p><em>Options API</em> унаследован от Vue 2 и предписывает, что компонент определяется объектом с определенными полями, ни одно из которых не является обязательным. Более того, некоторые из них имеют определенные параметры и ожидаемые выходы. Например, вот наиболее часто используемые поля (список также не является исчерпывающим):</p><ul><li><strong>data</strong> - должна быть функцией, возвращающей объект, поля которого станут реактивными переменными.</li><li><strong>methods</strong> - это объект, содержащий наши функции. Эти функции имеют доступ к реактивным переменным из data, используя формат <strong>this.variableName</strong></li><li><strong>components</strong> - объект, каждое поле которого содержит имя шаблона, а значение указывает на конструктор другого компонента (дочернего по отношению к текущему).</li><li><strong>computed</strong> - это объект, атрибуты которого определяют &quot;вычисляемые&quot; свойства. Каждый член - это функция или объект, который может быть использован в качестве реактивных переменных в нашем шаблоне и коде. Функции будут доступны только для чтения, а объекты могут содержать логику для чтения и записи в них значений. Эта концепция будет проясняться по мере просмотра примеров кода в главе 3 <em>Установка рабочего проекта</em>.</li><li><strong>props</strong> и <strong>emits</strong> объявляют параметры для получения данных от родительского компонента и объявляют события, отправляемые родительскому компоненту. Это обеспечивает формальный способ связи и передачи данных между связанными компонентами, но не единственный, как мы увидим в главе 7 <em>Управление потоком данных</em>.</li><li><strong>life cycle hooks</strong> - это ряд функций, которые запускаются в течение жизненного цикла компонента.</li><li><strong>миксины</strong> - это объекты, описывающие общую функциональность, которая может быть использована совместно в нескольких компонентах. Это не единственный способ повторного использования кода в Vue 3. Использование миксинов в API Options вызвало некоторые сложности, которые привели к появлению API Composition. Мы не будем подробно рассматривать миксины, но рассмотрим другие подходы к обмену функциональностью между компонентами (например, &quot;composables&quot;).</li></ul><p>Этот синтаксис хорошо определен, но имеет ряд ограничений. Для небольших компонентов он слишком сильно загромождает код, а для больших компонентов организация кода сильно страдает и получается очень многословной. Кроме того, для обращения к реактивным переменным, объявленным в секции <strong>data</strong>, или к другим методам во внутреннем коде приходится использовать ключевое слово <strong>this</strong> (например, <strong>this.data_variable_name</strong> или <strong>this.myMethod()</strong>). Ключевое слово <strong>this</strong> относится к созданному экземпляру компонента. Проблема заключается в том, что зарезервированное слово <strong>this</strong> меняет значение в зависимости от области и контекста использования. Есть и другие недостатки, проявившиеся со временем, которые привели к созданию Composition API. Однако данный синтаксис актуален и полностью поддерживается в Vue 3. Одним из его преимуществ является возможность легкой миграции кода из Vue 2 (с определенными оговорками, как показано далее в <em>Приложении - Миграция из</em> <em>Vue 2</em>).</p><p>Composition API предоставляет метод <strong>setup()</strong>, который выполняется перед установкой компонента. В этом методе мы импортируем функции и компоненты, объявляем переменные и т.д., которые определяют наш компонент, вместо того чтобы объявлять их как &quot;опции&quot;. Это означает, что вы можете писать свой код в бОльшей степени как на обычном JavaScript. Это дает вам свободу импортировать, повторно использовать и лучше организовывать свой код.</p><p>Давайте сравним эти два подхода на примере реактивной переменной, <strong>_hello=&quot;Hello World&quot;</strong>:</p><p><strong>Options API</strong></p><div class="language-vue vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { _hello: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Hello World&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p><strong>Composition API</strong></p><div class="language-vue vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { ref } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;vue&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  setup</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> _hello</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ref</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Hello World&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { _hello };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>В Options API мы просто используем поле <strong>data</strong>, чтобы вернуть объект, поля которого превратятся в реактивные переменные. Vue позаботится об интерпретации этого объекта. Однако обратите внимание, что в Composition API нам необходимо сначала импортировать из Vue конструктор <strong>ref</strong>, который создаст для нас реактивную константу или переменную. Конечный результат тот же, но здесь мы имеем более тонкий контроль над тем, что и где делается. При использовании нового сборщика Vite такой тонкий контроль над тем, что импортируется в наши компоненты, может привести к ускорению процесса создания кода и времени разработки.</p><p>На первый взгляд кажется, что Composition API более многословен, чем Options API, и так оно и есть для такого тривиального примера. Однако по мере роста нашего компонента все становится наоборот. Но все равно, многословность... Но существует альтернативный синтаксис для Composition API, называемый <em>script setup</em>, и именно его мы будем использовать в этой книге. Давайте теперь сравним, как выглядит этот компонент с новым синтаксисом:</p><p><strong>Composition API - script setup</strong></p><div class="language-vue vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setup</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { ref } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;vue&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> _hello</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ref</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Hello World&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>Две строки кода! Это трудно превзойти. Поскольку мы добавили атрибут <strong>setup</strong> в тег <strong>script</strong>, сборщик знает, что все, что мы здесь делаем, относится к области Composition API, и все функции, переменные и константы автоматически отображаются в шаблон. Нет необходимости определять экспорт. Если нам что-то нужно, мы импортируем это напрямую и используем. Кроме того, теперь у нас есть несколько дополнительных преимуществ, например, следующие:</p><ul><li>Мы можем иметь реактивные и нереактивные переменные, отображаемые в нашем шаблоне</li><li>Мы знаем, что весь код выполняется до того, как компонент будет смонтирован</li><li>Синтаксис ближе к ванильному JavaScript (большой плюс!!!), поэтому мы можем организовать наш код так, как нам удобно и приятно</li><li>Меньший размер пакета (я уже говорил об этом? Да, это важно!)</li></ul><p>Но подождите, вы можете заметить, что я определяю реактивную переменную как <em>константу</em>! Да, это так. И нет, это не ошибка. В JavaScript константа указывает на конкретное неизменяемое значение, которым в данном случае является объект, но это относится только к объекту, а не к его членам. Конструктор <strong>ref()</strong> возвращает объект, поэтому константа применяется к ссылке на объект, и мы <em>можем</em> изменять значения его членов. Если вы работали с указателями в Java, C или другом подобном языке, то, возможно, узнаете эту концепцию как использование <strong>указателей</strong>. Однако за все это приходится платить. Для того чтобы получить доступ к значению и изменить его, теперь необходимо получить доступ к атрибуту <strong>значение</strong> объекта. Вот пример:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">_hello.value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Некоторое другое значение&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>Но, в то же время, ничего не изменилось в способе доступа к этой переменной в шаблоне:</p><div class="language-vue vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;{{_hello}}&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>Кроме того, каждый раз, когда переменная объявляется как реактивная с помощью конструктора <strong>ref()</strong>, необходимо ссылаться на ее значение в формате <strong>constant_name.value</strong>, и как <strong>constant_name</strong> в шаблоне (HTML). Когда имя константы используется в шаблоне, Vue уже знает, как получить доступ к ее значению, и вам не нужно ссылаться на нее явно, как в JavaScript.</p><div class="tip custom-block"><p class="custom-block-title">Совет</p><p>Выработайте или примите соглашение о коде (code convention), чтобы знать, когда идентификатор относится к переменной, константе, функции, классу и т. д.</p></div><h2 id="изучение-встроенных-директив-в-vue-3" tabindex="-1">Изучение встроенных директив в Vue 3 <a class="header-anchor" href="#изучение-встроенных-директив-в-vue-3" aria-label="Permalink to &quot;Изучение встроенных директив в Vue 3&quot;">​</a></h2><p>В Vue также предусмотрены специальные атрибуты HTML, называемые <strong>директивами</strong>. Директива объявляется в открывающем теге HTML-элемента и влияет на динамическое поведение или функциональность этого элемента. Мы также можем создавать собственные директивы в Vue. Те из них, которые предоставляются фреймворком, имеют специальную нотацию, начинающуюся с <strong>v-</strong>. В рамках данной книги рассмотрим наиболее часто используемые директивы Vue:</p><h3 id="v-bind-сокращение" tabindex="-1">v-bind: (сокращение &quot;:&quot;) <a class="header-anchor" href="#v-bind-сокращение" aria-label="Permalink to &quot;v-bind: (сокращение \\&quot;:\\&quot;)&quot;">​</a></h3><p>Директива <strong>v-bind:</strong> связывает значение HTML-атрибута со значением переменной JavaScript. Если переменная является реактивной, то каждое обновление её значения будет отражаться в html. Если переменная не реактивная, то она будет использоваться только один раз при первоначальном рендеринге HTML. Чаще всего мы используем только сокращенный префикс <strong>:</strong> (двоеточие). Например, реактивная переменная <strong>my_profile_picture</strong> содержит веб-адрес к картинке:</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">img</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> :src</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;my_profile_picture&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span></code></pre></div><p>Атрибут <strong>src</strong> получит значение переменной <strong>my_profile_picture</strong></p><h3 id="v-show" tabindex="-1">v-show <a class="header-anchor" href="#v-show" aria-label="Permalink to &quot;v-show&quot;">​</a></h3><p>Эта директива показывает или скрывает элемент, не удаляя его из документа. Она эквивалентна модификации атрибута CSS <strong>display</strong>. Она ожидает переменную, которая дает булево значение (или то, что может быть интерпретировано как true или непустое). Например, переменная <strong>loading</strong> имеет булево значение:</p><div class="language-vue vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> v-show</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">loading</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;...&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>Этот <strong>div</strong> появится, когда переменная <strong>loading</strong> будет равна true.</p><p>Важно иметь в виду, что <strong>v-show</strong> будет использовать стиль объекта, чтобы отобразить его или нет, но элемент все равно будет частью <strong>Document Object Model</strong> (<strong>DOM</strong>)</p><h3 id="v-if-v-else-и-v-else-if" tabindex="-1">v-if, v-else и v-else-if <a class="header-anchor" href="#v-if-v-else-и-v-else-if" aria-label="Permalink to &quot;v-if, v-else и v-else-if&quot;">​</a></h3><p>Эти директивы ведут себя так же, как и условные предложения в JavaScript, показывая и скрывая элемент в зависимости от значения, определяемого переданным выражением. Они похожи на <strong>v-show</strong> в том смысле, что показывают или скрывают элемент, но с той разницей, что они полностью удаляют элемент из DOM. Из-за этого при неправильном использовании в больших масштабах с элементами, часто меняющими свое состояние, они могут быть дороги в вычислительном отношении, так как фреймворку приходится выполнять больше операций для манипулирования DOM, в отличие от <strong>v-show</strong>, когда нужно изменить только стиль отображения.</p><div class="tip custom-block"><p class="custom-block-title">Совет</p><p>Используйте <strong>v-if</strong> для показа или отображения элементов, которые не будут переключаться после показа или скрытия (и предпочтительно, если начальное состояние скрыто). Используйте <strong>v-show</strong>, если элемент будет часто показываться/скрываться. Это улучшит производительность при отображении больших списков элементов.</p></div><h3 id="v-for-и-key" tabindex="-1">v-for и :key <a class="header-anchor" href="#v-for-и-key" aria-label="Permalink to &quot;v-for и :key&quot;">​</a></h3><p>В сочетании эти два атрибута ведут себя подобно циклу <strong>for</strong> в JavaScript. Они создают столько копий элемента, сколько прописано в итераторе, каждая из которых имеет соответствующее интерполированное значение. Это очень удобно для отображения коллекций элементов данных. Атрибут <strong>:key</strong> используется внутри цикла для более эффективного отслеживания изменений и должен ссылаться на уникальный атрибут элемента, по которому выполняется цикл - например, на поле <strong>id</strong> объекта или на индекс в массиве, если индексы не меняются. Вот пример:</p><div class="language-vue vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">span</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> v-for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 5</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> :</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">i</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {{i}} &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">span</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>Таким образом на веб-странице будет отображено пять элементов <strong>span</strong> с интерполяцией <strong>i</strong>, что выглядит следующим образом:</p><p><strong>1 2 3 4 5</strong></p><h3 id="v-model" tabindex="-1">v-model <a class="header-anchor" href="#v-model" aria-label="Permalink to &quot;v-model&quot;">​</a></h3><p>Эта директива - чистая магия. При присоединении к элементу ввода (input, textarea, select и т.д.) она присваивает значение, возвращаемое HTML-элементом, ссылаемой переменной, поддерживая тем самым синхронизацию состояния DOM и JavaScript, что называется <strong>двусторонним связыванием</strong>. Вот пример:</p><div class="language-vue vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">input</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;text&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> v-model</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">name</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>Когда пользователь вводит текст в HTML, переменной <strong>name</strong> в JavaScript сразу же присваивается это значение. В этих примерах мы используем примитивные типы данных, такие как числа и строки, но мы можем использовать и более сложные значения, такие как объекты или массивы. Подробнее об этом будет рассказано в главе 4 <em>Композиция пользовательского интерфейса с компонентами</em>, когда мы рассмотрим компоненты в деталях.</p><h3 id="v-on-и-сокращение" tabindex="-1">v-on: (и сокращение @) <a class="header-anchor" href="#v-on-и-сокращение" aria-label="Permalink to &quot;v-on: (и сокращение @)&quot;">​</a></h3><p>Эта директива ведет себя несколько иначе, чем предыдущие. Она ожидает не переменную, а функцию или выражение, и связывает HTML-событие с функцией JavaScript для его выполнения. Событие должно быть объявлено сразу после двоеточия. Например, чтобы отреагировать на событие <strong>click</strong> на кнопке мыши, мы напишем следующее:</p><div class="language-vue vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> v-on</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">click</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">printPage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;Print&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>Когда кнопка вызывает событие <strong>click</strong>, будет выполнена функция JavaScript <strong>printPage()</strong>. Кроме того, для этой директивы чаще используется сокращение, которое мы и будем использовать в дальнейшем в этой книге: просто замените <strong>v-on:</strong> на <strong>@</strong>. Тогда предыдущий пример превратится в следующий:</p><div class="language-vue vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> @</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">click</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">printPage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;Print&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>Полный список встроенных директив можно найти в официальной документации здесь: <a href="https://vuejs.org/api/built-in-directives.html" target="_blank" rel="noreferrer">https://vuejs.org/api/built-in-directives.html</a>. По мере продвижения вперед мы увидим и другие.</p><p>До сих пор мы видели, что приложения Vue 3 строятся с помощью компонентов, которые мы можем использовать в нашем HTML и которые мы создаем с помощью SFC. Фреймворк также предоставляет нам директивы для работы с элементами HTML, но это еще не все. В следующем разделе мы увидим, что фреймворк также предоставляет несколько удобных готовых компонентов, которые мы можем использовать.</p><h2 id="встроенные-компоненты" tabindex="-1">Встроенные компоненты <a class="header-anchor" href="#встроенные-компоненты" aria-label="Permalink to &quot;Встроенные компоненты&quot;">​</a></h2><p>Фреймворк также предоставляет нам несколько встроенных компонентов, которые мы можем использовать, не импортируя их явно в каждый SFC. Я привел здесь небольшое описание каждого из них, поэтому за синтаксисом и примерами можно обратиться к официальной документации (см. <a href="https://vuejs.org/api/built-in-components.html" target="_blank" rel="noreferrer">https://vuejs.org/api/built-in-components.html</a>):</p><ul><li><p><strong>Transition</strong> и <strong>TransitionGroup</strong> - это два компонента, которые могут работать вместе для обеспечения анимации и перехода элементов и компонентов. Они требуют создания CSS-анимации и классов переходов для реализации анимации при вставке или удалении элементов на странице. В основном (или часто) они используются при отображении списка элементов с помощью директив <strong>v-for/:key</strong> или <strong>v-if/v-show</strong>.</p></li><li><p><strong>KeepAlive</strong> - это еще один компонент-обертка (то есть окружение других компонентов), используемый для сохранения состояния (внутренних переменных, элементов и т.д.), когда компонент, обернутый в него, больше не отображается. Обычно при размонтировании экземпляры компонентов очищаются и &quot;собираются в мусор&quot;. <strong>KeepAlive</strong> сохраняет их в кэше, чтобы их состояние было восстановлено, когда они снова появятся на экране.</p></li><li><p><strong>Teleport</strong> - совершенно новый компонент в Vue 3, который позволяет переносить HTML компонента в другое место на странице, даже за пределы дерева компонентов вашего приложения. Это помогает в некоторых случаях, когда необходимо вывести информацию за пределы компонента, но она должна быть обработана внутренней логикой компонента.</p></li><li><p><strong>Suspense</strong> - новый компонент в Vue 3, но пока он находится в экспериментальной стадии, поэтому его будущее на момент написания статьи не определено. Основная идея заключается в отображении &quot;запасного&quot; контента до тех пор, пока все асинхронные дочерние компоненты/элементы не будут готовы к рендерингу. Он предоставляется для удобства, поскольку существуют шаблоны, которые можно использовать для решения этой проблемы. Мы рассмотрим их позже.</p></li><li><p><strong>Component-is</strong> - это специальный элемент, который будет загружать компонент во время выполнения, как предписано содержимым переменной - например, если нам нужно отобразить компонент на основе значения переменной, а использование других директив может быть громоздким. Она также может быть использована для вывода HTML-элементов. Рассмотрим пример:</p></li></ul><div class="language-vue vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setup</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> EditItem </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;EditItem.vue&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ViewItem </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;ViewItem.vue&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { ref } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;vue&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> action</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ref</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;ViewItem&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;     </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">component</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> :is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;action&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;     </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> @click</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;action = &#39;EditItem&#39;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;Edit&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>В этом простом примере, когда пользователь нажмет кнопку <strong>Edit</strong>, значение action изменится на <strong>EditItem</strong>, и компонент заменится. Документацию можно найти здесь:<a href="https://vuejs.org/api/built-in-special-elements.html" target="_blank" rel="noreferrer">https://vuejs.org/api/built-in-special-elements.html</a>.</p><p>Поняв, что такое фреймворки и компоненты, мы теперь лучше подготовлены к дальнейшей работе.</p><h2 id="кодовые-соглашения-code-conventions-в-книге" tabindex="-1">Кодовые соглашения (code conventions) в книге <a class="header-anchor" href="#кодовые-соглашения-code-conventions-в-книге" aria-label="Permalink to &quot;Кодовые соглашения (code conventions) в книге&quot;">​</a></h2><p>В этой книге мы будем использовать набор кодовых соглашений и рекомендаций, которые являются хорошей практикой для Vue 3. Они помогут вам не только понять примеры, приведенные в этой книге, но и код, который вы можете встретить в природе, поскольку все больше разработчиков используют его. Давайте начнем с самого начала.</p><h3 id="переменные-и-пропсы" tabindex="-1">Переменные и пропсы <a class="header-anchor" href="#переменные-и-пропсы" aria-label="Permalink to &quot;Переменные и пропсы&quot;">​</a></h3><p>Они всегда пишутся в нижнем регистре, а пробелы заменяются знаком подчеркивания, например, <strong>total_count</strong> и <strong>person_id</strong>.</p><h3 id="константы" tabindex="-1">Константы <a class="header-anchor" href="#константы" aria-label="Permalink to &quot;Константы&quot;">​</a></h3><p>Ссылки на инжектируемые объекты начинаются со знака <strong>$</strong>, например, <strong>$router</strong>, <strong>$modals</strong> и <strong>$notifications</strong>.</p><p>Ссылки на реактивные данные начинаются с <strong>_</strong> и набираются в змеином регистре (snake case), например, <strong>_total</strong> и <strong>_first_input</strong>.</p><p>Ссылки на константные значения обозначаются заглавными буквами, например, <strong>OPTION</strong> и <strong>LANGUAGE_CODE</strong>.</p><p>Функции-конструкторы для инжектируемых зависимостей будут начинаться с <strong>use</strong>, например, <strong>const $store=useStore()</strong>.</p><h3 id="имена-классов-и-компонентов" tabindex="-1">Имена классов и компонентов <a class="header-anchor" href="#имена-классов-и-компонентов" aria-label="Permalink to &quot;Имена классов и компонентов&quot;">​</a></h3><p>Они записываются в PascalCase (каждое слово начинается с буквы верхнего регистра), например, <strong>Person</strong>, <strong>Task</strong> и <strong>QueueBuilder</strong>.</p><h3 id="функции-методы-события-и-имена-фаилов" tabindex="-1">Функции, методы, события и имена файлов <a class="header-anchor" href="#функции-методы-события-и-имена-фаилов" aria-label="Permalink to &quot;Функции, методы, события и имена файлов&quot;">​</a></h3><p>Они пишутся в CamelCase, например, <strong>doSubscribe()</strong> и <strong>processQueue()</strong>.</p><h3 id="экземпляры" tabindex="-1">Экземпляры <a class="header-anchor" href="#экземпляры" aria-label="Permalink to &quot;Экземпляры&quot;">​</a></h3><p>Экземпляры будут иметь абстрактное имя, за которым следует слово <strong>Service</strong> в случае обычных JavaScript-объектов, предоставляющих функции, <strong>Model</strong> для моделей состояний и так далее. Мы будем использовать сервисы для инкапсуляции функциональности.</p><p>Например: <strong>const</strong> <strong>projectService=new ProjectService()</strong>.</p><div class="tip custom-block"><p class="custom-block-title">Совет</p><p>В своей команде всегда используйте кодовые соглашения, с которыми все согласны. Это сделает код более читаемым и удобным для сопровождения. Можно также порекомендовать использовать линтер (процессор для фиксации соглашений в коде).</p></div><p>Как уже говорилось, эти соглашения набирают популярность, поэтому вы можете встретить их во многих проектах. Однако они не являются обязательными стандартами и уж точно не предписаны фреймворком. Вы можете писать все заглавными буквами, если это ваш стиль, но на самом деле важно, чтобы вы и ваша команда определили и соблюдали свои собственные соглашения в последовательной манере. В конечном итоге важно, чтобы при написании кода у всех нас был общий язык.</p><h2 id="подведение-итогов" tabindex="-1">Подведение итогов <a class="header-anchor" href="#подведение-итогов" aria-label="Permalink to &quot;Подведение итогов&quot;">​</a></h2><p>В этой главе мы прошли путь от основ библиотек и фреймворков до директив Vue 3, компонентов и даже кодовых соглашений. Эти понятия все еще немного абстрактны, поэтому мы будем доводить их до реализации по мере продвижения по книге и работы с реальным кодом. Однако сейчас мы готовы для изучения принципов проектирования и паттернов в следующей главе.</p><h2 id="вопросы-для-проверки" tabindex="-1">Вопросы для проверки <a class="header-anchor" href="#вопросы-для-проверки" aria-label="Permalink to &quot;Вопросы для проверки&quot;">​</a></h2><p>Для того чтобы помочь вам закрепить содержание этой главы, вы можете воспользоваться следующими вопросами:</p><ul><li>В чем разница между библиотекой и фреймворком?</li><li>Почему Vue является &quot;прогрессивным&quot; фреймворком?</li><li>Что такое однофайловые компоненты?</li><li>Какие директивы наиболее часто используются при разработке Vue?</li><li>Почему важны соглашения в коде?</li></ul><p>Если вы можете быстро ответить на эти вопросы в уме, то вы готовы к работе! Если нет, то, возможно, вам стоит кратко просмотреть главу, чтобы убедиться, что у вас есть основа для дальнейшей работы.</p>`,102);function C(t,q,A,_,D,f){return p(),l("div",null,[r,i("p",null,[s("В разделе "),o,s(" мы определяем тег "),g,s(" и импортируем Vue из бесплатной "),E,s(" ("),d,s("). При этом создается глобальная переменная "),c,s(", которая открывает все методы и функции фреймворка. Внутри нашего тега "),u,s(" мы объявляем элемент "),y,s(" с "),m,s(". Это определяет, где будет размещено наше небольшое приложение и какой частью страницы будет управлять фреймворк Vue. Обратите внимание на содержимое "),i("strong",null,"div: "+e(t.message),1),s(". Двойные фигурные скобки определяют точку, в которой содержимое будет заменено во время выполнения на значение переменной "),v,s(", которую мы определяем в JavaScript. Это называется "),F,s(" и является основным способом отображения значения (строки, числа и т.д.) на веб-странице.")]),b])}const S=n(k,[["render",C]]);export{V as __pageData,S as default};
