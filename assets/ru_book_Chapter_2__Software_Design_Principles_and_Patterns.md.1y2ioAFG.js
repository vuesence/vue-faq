import{_ as i,c as a,o as n,ah as t}from"./chunks/framework.CH-e-O8w.js";const h="/assets/Figure_2.01_B18602.BjVAkxPg.jpg",p="/assets/Figure_2.02_B18602.C10efs3e.jpg",l="/assets/Figure_2.03_B18602.B2O7SQqV.jpg",k="/assets/Figure_2.04_B18602.rVt1Cldv.jpg",e="/assets/Figure_2.05_B18602.BwmrX0Yq.jpg",r="/assets/Figure_2.06_B18602.Vn9eVNDg.jpg",E="/assets/Figure_2.07_B18602.iZAHF3WT.jpg",d="/assets/Figure_2.08_B18602.CondL_kl.jpg",D=JSON.parse('{"title":"Принципы и шаблоны проектирования программного обеспечения","description":"Учебник по Vue.js 3","frontmatter":{"pageClass":"textbook","head":[["meta",{"name":"og:site_name","content":"Vue.js 3 - Шаблоны проектирования и лучшие практики"}],["meta",{"name":"description","content":"Учебник по Vue.js 3"}],["meta",{"name":"og:image","content":"/images/book-face.jpg"}],["meta",{"name":"twitter:image","content":"/images/book-face.jpg"}]]},"headers":[],"relativePath":"ru/book/Chapter_2__Software_Design_Principles_and_Patterns.md","filePath":"ru/book/Chapter_2__Software_Design_Principles_and_Patterns.md","lastUpdated":1738480984000}'),g={name:"ru/book/Chapter_2__Software_Design_Principles_and_Patterns.md"};function o(y,s,c,F,u,A){return n(),a("div",null,s[0]||(s[0]=[t('<h1 id="принципы-и-шаблоны-проектирования-программного-обеспечения" tabindex="-1">Принципы и шаблоны проектирования программного обеспечения <a class="header-anchor" href="#принципы-и-шаблоны-проектирования-программного-обеспечения" aria-label="Permalink to &quot;Принципы и шаблоны проектирования программного обеспечения&quot;">​</a></h1><p>Разработка программного обеспечения по своей сути является <em>человекоемкой дисциплиной</em>. Это означает, что она требует не только знания техники и технологии, но и понимания проблемы и умения принимать решения для реализации решения на нескольких уровнях абстракции.</p><p>Программирование во многом зависит от того, как мыслит разработчик. С годами в каждом контексте и языке появились рекомендации и решения для решения повторяющихся проблем. Знание этих <em>паттернов</em> (<em>шаблонов</em>) поможет вам определить, когда их следует применять, и ускорить разработку. С другой стороны, <em>принципы</em> - это руководящие концепции, которые должны применяться на каждом этапе процесса, и они в большей степени зависят от того, как вы подходите к процессу.</p><p>В этой главе мы рассмотрим неполный и не исчерпывающий список принципов и шаблонов, которые часто встречаются при разработке приложений на Vue 3.</p><p><strong>Принципы разработки ПО</strong></p><ul><li>Separation of concerns (Разделение ответственности)</li><li>Composition over inheritance (Композиция вместо наследования)</li><li>Single responsibility (Единая ответственность)</li><li>Encapsulation (Инкапсуляция)</li><li>KIC - keep it clean (держи это чистым)</li><li>DRY - don’t repeat yourself (не повторяться)</li><li>KISS - keep it simple stupid (держи это максимально простым)</li><li>Code for the next (пиши код для следующего программиста)</li></ul><p><strong>Шаблоны проектирования</strong></p><ul><li>Singleton (Синглтон)</li><li>Dependency injection (Инъекция зависимостей)</li><li>Observer (Обсервер)</li><li>Command (Команда)</li><li>Proxy (Прокси)</li><li>Decorator (Декоратор)</li><li>Façade (Фасад)</li><li>Callbacks (Обратные вызовы)</li><li>Promises (Промисы)</li></ul><p>Понимание этих принципов и шаблонов поможет вам использовать фреймворк более эффективно и чаще всего не позволит вам &quot;изобретать велосипед&quot;. Вместе с первой главой эта глава завершает <em>фундаментальную часть</em> данной книги и дает основу для изучения практической части и реализации примеров приложений в остальных частях книги.</p><h2 id="каковы-принципы-проектирования-программного-обеспечения" tabindex="-1">Каковы принципы проектирования программного обеспечения? <a class="header-anchor" href="#каковы-принципы-проектирования-программного-обеспечения" aria-label="Permalink to &quot;Каковы принципы проектирования программного обеспечения?&quot;">​</a></h2><p>При разработке программного обеспечения принципы проектирования - это концептуальные рекомендации высокого уровня, которые должны применяться ко всему процессу. Не в каждом проекте будут использоваться одни и те же принципы, и это не обязательные правила, которые должны соблюдаться. Они могут проявляться в проекте, начиная с архитектуры и заканчивая <strong>пользовательским интерфейсом</strong> (<strong>UI</strong>) и последним фрагментом кода. На практике некоторые из этих принципов могут также влиять на такие атрибуты программного обеспечения, как сопровождаемость (maintainability) и возможность повторного использования (re-usability).</p><h2 id="неполныи-список-принципов-проектирования" tabindex="-1">Неполный список принципов проектирования <a class="header-anchor" href="#неполныи-список-принципов-проектирования" aria-label="Permalink to &quot;Неполный список принципов проектирования&quot;">​</a></h2><p>Принципы проектирования несколько различаются в зависимости от контекста, области и даже команды, в которой человек работает в данный момент. Поэтому принципы, включенные в данную главу, являются неисчерпывающими.</p><h3 id="separation-of-concerns-разделение-ответственности" tabindex="-1">Separation of concerns (Разделение ответственности) <a class="header-anchor" href="#separation-of-concerns-разделение-ответственности" aria-label="Permalink to &quot;Separation of concerns (Разделение ответственности)&quot;">​</a></h3><p>Это, пожалуй, самый важный принцип в программной инженерии. Разделение ответственности подразумевает, что система должна быть разделена на подсистемы элементов, сгруппированных по их функциям или услугам (<strong>ответственности</strong>). Например, мы можем рассматривать человеческий организм как <em>систему</em>, состоящую из множества подсистем (дыхательной, кровеносной, пищеварительной и т.д.). Они, в свою очередь, объединены различными органами, которые состоят из тканей, и так далее, вплоть до мельчайшей клетки. Следуя той же идее в программном обеспечении, приложение можно разделить на элементы, сгруппированные по проблемам, начиная с большой архитектуры и заканчивая последней функцией. Без такого разделения сложности на управляемые части создать функциональную систему было бы гораздо сложнее, а то и вовсе невозможно.</p><p>В общем случае применение этого принципа начинается с общей картины того, какой должна быть система, рассматривает, что она должна делать для достижения этой цели, а затем разбивает ее на управляемые рабочие части.</p><p>В качестве примера приведем грубое графическое представление разделения задач для веб-приложения. Каждый квадрат на этой диаграмме обозначает отдельную зону <em>ответственности</em>, которая, в свою очередь, может быть детализирована на более мелкие функциональные части. Еще лучше, если вы увидите, как этот принцип позволяет выявить интегрирующие части системы.</p><p><img src="'+h+'" alt="image"></p><p>Рисунок 2.1 - Простой архитектурный вид веб-приложения, демонстрирующий разделение ответственности</p><p>Если мы будем углубляться в любую из этих маленьких ячеек внутри соответствующих доменов, мы сможем найти еще больше проблем, которые можно разделить, пока не достигнем неделимого атомарного элемента (компонента или функции, например). Этот принцип имеет много общего с другими принципами, такими как абстракция и единая ответственность, и выигрывает от них. Мы рассмотрим их далее в этой же главе.</p><h3 id="composition-over-inheritance-композиция-над-наследованием" tabindex="-1">Composition over inheritance (Композиция над наследованием) <a class="header-anchor" href="#composition-over-inheritance-композиция-над-наследованием" aria-label="Permalink to &quot;Composition over inheritance (Композиция над наследованием)&quot;">​</a></h3><p>Принцип <em>композиции над наследованием</em> заимствован непосредственно из <strong>объектно-ориентированного программирования</strong> (<strong>ООП</strong>). Он гласит, что объект должен пытаться использовать функциональность других объектов, когда это необходимо, путем ссылки на них или инстанцирования, а не создавать большое и сложное дерево классов наследования для добавления такой функциональности.</p><p>В наши дни, JavaScript по своей сути является <em>функциональным</em> языком, хотя и поддерживает множество парадигм, включая черты ООП, поэтому этот принцип также применим. Есть одно предостережение для тех, кто переходит с ООП на JavaScript - не поддавайтесь искушению рассматривать JavaScript как чистый ООП-язык. Это может привести к ненужным сложностям, вместо того чтобы воспользоваться достоинствами языка.</p><p>В Vue 3 не существует расширения или наследования компонентов. Когда нам нужна общая или наследуемая функциональность, у нас есть хороший набор инструментов для замены парадигмы наследования. Как соблюсти этот принцип, используя <em>композитные компоненты</em>, мы увидим позже в главе 4, <em>Композиция пользовательского интерфейса с помощью компонентов.</em></p><h3 id="single-responsibility-principle-принцип-единои-ответственности" tabindex="-1">Single responsibility principle (Принцип единой ответственности) <a class="header-anchor" href="#single-responsibility-principle-принцип-единои-ответственности" aria-label="Permalink to &quot;Single responsibility principle (Принцип единой ответственности)&quot;">​</a></h3><p>Этот принцип можно встретить как в ООП, так и в функциональном программировании. Проще говоря, он гласит, что класс, метод, функция или <em>компонент</em> должны иметь дело только с одной ответственностью или функциональностью.</p><p>Если вы работали в других дисциплинах и языках, то это естественно. Многоцелевые функции трудно поддерживать и они имеют тенденцию выходить из-под контроля, особенно в таких языках, как JavaScript, который является слабо типизированным и очень динамичным. Эта же концепция напрямую относится и к компонентам Vue 3. Каждый компонент должен выполнять одну конкретную операцию и не пытаться делать слишком много самостоятельно.</p><p>На практике, когда компонент выходит за определенные рамки, лучше разделить его на несколько компонентов или вынести поведение во внешние модули. Бывают случаи, когда в итоге получается компонент длиной в несколько тысяч строк, но, по моему опыту, это редко бывает необходимо, и этого можно и нужно избегать. Однако следует предупредить, что излишняя конкретика также может привести к ненужному усложнению.</p><p>В качестве примера представим себе экран входа в систему, на котором также отображается опция регистрации. Такой подход встречается сегодня на многих сайтах. Можно включить все функции в один компонент, но это нарушит данный принцип. Лучшей альтернативой будет разделение компонентов как минимум на три компонента для решения этой задачи:</p><ul><li>Родительский компонент, который управляет логикой пользовательского интерфейса. Этот компонент решает, когда показывать/скрывать компоненты входа и регистрации.</li><li>Дочерний компонент, выполняющий функцию входа.</li><li>Дочерний компонент, выполняющий функцию регистрации.</li></ul><p>Здесь представлено графическое представление данной конфигурации:</p><p><img src="'+p+`" alt="image"></p><p>Рисунок 2.2 - Композиция интерфейса входа/регистрации с использованием нескольких компонентов.</p><p>Я думаю, что вы быстро поймете преимущества этого принципа. Он облегчает управление, поддержку и адаптацию кода, поскольку веб-приложения имеют свойство очень и очень быстро мутировать и развиваться.</p><div class="tip custom-block"><p class="custom-block-title">Совет из Лучших практик</p><p>Наделите компоненты единой ответственностью и функциональностью. По возможности избегайте монолитных компонентов.</p></div><h3 id="encapsulation-инкапсуляция" tabindex="-1">Encapsulation (Инкапсуляция) <a class="header-anchor" href="#encapsulation-инкапсуляция" aria-label="Permalink to &quot;Encapsulation (Инкапсуляция)&quot;">​</a></h3><p>Инкапсуляция - это представление о том, что данные и методы должны быть обернуты в единое целое и при этом предоставлять четко определенный <strong>интерфейс прикладного программирования</strong> (<strong>API</strong>).</p><p>Часто это делается в виде классов, модулей или библиотек. JavaScript не является исключением, и настоятельно рекомендуется следовать этому принципу. В Vue 3 эта концепция распространяется не только на компоненты, но и на стили CSS и HTML. Введение <em>однофайловых компонентов</em> - яркий пример того, как фреймворк продвигает этот принцип в действии и насколько он важен для современной разработки.</p><p>За исключением некоторых редких случаев мы должны рассматривать компоненты (<strong>UI</strong>) как &quot;черные ящики&quot;, которые принимают входящие параметры и предоставляют исходящие данные. Другие компоненты не должны быть <em>знакомы</em> с их внутренним устройством, только с API. По мере создания примеров приложений, описанных в этой книге, вы увидите этот принцип в действии.</p><h3 id="kic-keep-it-clean" tabindex="-1">KIC - keep it clean <a class="header-anchor" href="#kic-keep-it-clean" aria-label="Permalink to &quot;KIC - keep it clean&quot;">​</a></h3><p>Этот принцип относится главным образом к тому, как <em>вы пишете</em> код. Здесь я должен подчеркнуть, что KIC непосредственно относится к двум категориям, которые сильно влияют на веб-приложения и приложения Vue 3:</p><ul><li>Как вы форматируете свой код</li><li>Как вы упорядочиваете события и переменные</li></ul><p>Первый пункт включает в себя использование кодовых соглашений, комментариев и отступов для организации кода и логической группировки функций. Например, если у вас есть методы, которые работают с операциями <strong>создания, чтения, обновления и удаления</strong> (<strong>CRUD</strong>), то лучше всего разместить их в коде рядом друг с другом, а не разбрасывать по всему исходному файлу.</p><p>Многие <strong>интегрированные среды разработки</strong> (<strong>IDE</strong>) содержат функции, позволяющие сворачивать или разворачивать внутренний код функций. Это помогает быстро просматривать и находить в коде участки с похожей логикой.</p><p>Вторая часть этого принципа связана с обработкой памяти и ссылок. JavaScript имеет очень хороший сборщик мусора, функция которого заключается в отбрасывании неиспользуемых данных для освобождения памяти. Однако бывают случаи, когда алгоритм не может освободить ресурсы из-за наличия оставшихся ссылок. Если вы работали с другими языками, такими как C/C++, то эта проблема может показаться вам знакомой, поскольку вам необходимо вручную резервировать и освобождать память, когда она не используется.</p><p>В JavaScript, если вы регистрируете функцию для прослушивания события, лучше всего вручную снять ее с регистрации в соответствующем событии жизненного цикла компонента, когда она больше не нужна. Это позволит избежать утечек и нерационального использования памяти, а также предотвратить некоторые риски безопасности (которые выходят за рамки данной книги).</p><p>Мы рассмотрим жизненный цикл компонента в главе 4, <em>Композиция пользовательского интерфейса с помощью компонентов</em>, а пока возьмем следующий пример в качестве хорошего применения этого принципа и сохраним его в качестве лучшей практики. В этом примере мы создадим <em>компонуемый</em> компонент для обнаружения изменения размера окна, поэтому в разделе <code>script setup</code> мы найдем что-то подобное этому:</p><ol><li>Регистрируем функцию на событие изменения размера объекта окна в состоянии монтирования.</li><li>Снимаем регистрацию события перед размонтированием компонента.</li></ol><p>Здесь приведен фрагмент кода:</p><div class="language-vue vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setup</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { onBeforeUnmount, onMounted } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;vue&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onMounted</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  window.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;resize&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, myFunction);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onBeforeUnmount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  window.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">removeEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;resize&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, myFunction);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> myFunction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // Делаем что-то с событием здесь</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>Функции <strong>onMounted</strong> и <strong>onBeforeUnmount</strong> являются частью фреймворка Vue 3 и вызываются соответствующим событием жизненного цикла компонента. Здесь мы прикрепляем нашу функцию к событию <strong>resize</strong>, когда компонент монтируется в <strong>Document Object Model</strong> (<strong>DOM</strong>), и освобождаем ее непосредственно перед удалением. Важно помнить, что необходимо убирать за собой и <em>keep it clean</em>.</p><h3 id="dry-–-don-t-repeat-yourself-не-повторяися" tabindex="-1">DRY – don’t repeat yourself (не повторяйся) <a class="header-anchor" href="#dry-–-don-t-repeat-yourself-не-повторяися" aria-label="Permalink to &quot;DRY – don’t repeat yourself (не повторяйся)&quot;">​</a></h3><p>Этот принцип достаточно известен, почти превратился в клише. К сожалению, его легко забыть. Его авторство принадлежит Эндрю Ханту и Дэвиду Томасу, которые использовали его в книге <em>Прагматичный программист</em>. Чаще всего его понимают как <em>не пиши одно и то же дважды</em>, и это не так уж и далеко от истины, но он выходит за рамки этого понятия.</p><p>Он включает в себя понятие избегания избыточности как в процессе, так и в логике приложения. Основная идея заключается в том, что каждый процесс, выполняющий бизнес-логику, должен существовать только в одном месте во всем приложении.</p><p>Например, большинство веб-приложений имеют асинхронную связь с сервером через API. В приложении может быть несколько элементов, которые будут использовать или должны использовать эту связь между удаленным компьютером и сервером. Если бы вы собирались написать весь код/логику взаимодействия с сервером в каждом компоненте, то в итоге мы бы получили не только дублирование кода, но и логики приложения. Такая система открыла бы двери для огромного количества негативных побочных эффектов, проблем с безопасностью, плохой работы пользователей и многого другого.</p><p>В соответствии с этим принципом более правильным подходом является абстрагирование всего коммуникационного кода, связанного с API сервера, в единый модуль или класс. На практике в JavaScript это можно даже делегировать веб-рабочему в отдельном потоке. Мы рассмотрим эту реализацию позже в главе 8, <em>Многопоточность с Web Workers</em>.</p><p>Как правило, если вы видите, что пишете один и тот же код в разных компонентах или классах, то это явная возможность абстрагировать функциональность в отдельный модуль или компонент.</p><h3 id="kiss-keep-it-simple-and-short-держи-это-простым-и-коротким" tabindex="-1">KISS - keep it simple and short (держи это простым и коротким) <a class="header-anchor" href="#kiss-keep-it-simple-and-short-держи-это-простым-и-коротким" aria-label="Permalink to &quot;KISS - keep it simple and short (держи это простым и коротким)&quot;">​</a></h3><p>Этот принцип не является исключительным для сферы разработки программного обеспечения. Он был введен в обиход военно-морскими силами США еще в 60-х годах (согласно Википедии, <a href="https://en.wikipedia.org/wiki/KISS_principle" target="_blank" rel="noreferrer">https://en.wikipedia.org/wiki/KISS_principle</a>).</p><p>Идея основана на здравом смысле: лучше создавать простые, небольшие функциональные части, которые работают вместе, чем пытаться создать большую и сложную программу за один раз. Кроме того, алгоритмы должны быть реализованы наиболее простым и эффективным способом. В веб-разработке этот принцип очень важен.</p><p>Современные веб-приложения состоят из сотен работающих частей, распределенных по нескольким компьютерам, серверам и средам. Чем сложнее система или реализация кода, тем труднее ее обслуживать и адаптировать.</p><p>Однако есть одно предостережение. Простота не означает чрезмерного упрощения или ненужного разделения. Слишком большое количество мелких деталей может внести в систему ненужную сложность. Применять принцип KISS означает оставаться в той средней точке, где все поддается управлению и легко понимается.</p><h3 id="code-for-the-next-пиши-код-для-следующего" tabindex="-1">Code for the next (Пиши код для следующего) <a class="header-anchor" href="#code-for-the-next-пиши-код-для-следующего" aria-label="Permalink to &quot;Code for the next (Пиши код для следующего)&quot;">​</a></h3><p>Этот принцип заключается в том, что вы должны сделать свой код читаемым и понятным для кого-то еще, кроме вас. Соглашения об именовании, логический поток и межстрочные комментарии являются частью этого принципа. Не только для случая, когда вам придется передать свой код другому, но и когда вы вернетесь через год или два к тому же самому коду.</p><p>Меньше всего вам хочется тратить время на размышления о том, что же сделал прошлый неопытный человек с той заумной строчкой спагетти-кода. Умные разработчики пишут код так, как будто собираются учить кого-то другого, просто и элегантно. Особенно если вы используете открытый код или вносите в него свой вклад, этот принцип жизненно важен для групповой работы.</p><p>В этом случае стоит упомянуть о <em>принципе бойскаута</em>, который аналогичен, но применяется в группах. Он гласит, что если вы обнаружили трудночитаемый или &quot;спагетти&quot;-код, то рефакторите его, чтобы сделать чистым.</p><div class="tip custom-block"><p class="custom-block-title">Совет из Лучших практик</p><p>Содержите свой код в чистоте, используя комментарии и документацию, объясняющие логику, как будто учите кого-то другого. Чаще всего вы сами себя учите.</p></div><p>Принципы проектирования применимы ко многим различным сценариям, некоторые из них выходят за рамки практики разработки программного обеспечения. Важно усваивать их до тех пор, пока они не станут привычными. В целом, применение этих и других принципов, а также шаблонов проектирования накладывает существенный отпечаток на ваше профессиональное развитие.</p><h2 id="что-такое-шаблон-проектирования-программного-обеспечения" tabindex="-1">Что такое шаблон проектирования программного обеспечения? <a class="header-anchor" href="#что-такое-шаблон-проектирования-программного-обеспечения" aria-label="Permalink to &quot;Что такое шаблон проектирования программного обеспечения?&quot;">​</a></h2><p>При разработке программного обеспечения часто бывает так, что определенные процессы и задачи встречаются в нескольких проектах, в том или ином виде, или с некоторыми вариациями. Шаблон проектирования - это проверенное решение для подобных задач. Он не предписывает код, а действует как шаблон рассуждений, подход, абстрагированный независимо от реализации, для повторного использования и адаптации к конкретным условиям.</p><p>На практике применение шаблона дает большой простор для творчества. Этой теме посвящены целые книги, в которых приводится больше подробностей, чем позволяет объем данной книги. На следующих страницах мы рассмотрим наиболее часто встречающиеся, на мой взгляд, шаблоны, которые следует иметь в виду при работе с приложениями Vue 3.</p><p>Несмотря на то, что для целей изучения мы видим их по отдельности, в реальности часто реализация накладывает, смешивает и заключает в себе несколько шаблонов в одном фрагменте кода. Например, вы можете использовать <strong>синглтон</strong> для выполнения функций <strong>декоратора</strong> и <strong>прокси</strong> для упрощения или изменения взаимодействия между сервисами в вашем приложении (на самом деле мы будем делать это довольно часто, и полный код можно увидеть в Глава 8, <em>Многопоточность с Web Workers</em>).</p><p>Шаблоны проектирования также можно понимать как <em>лучшие практики</em> в области программной инженерии и разработки. А противоположную ей, <em>плохую практику</em>, часто называют <strong>антипаттерном</strong>. Антипаттерны - это &quot;решения&quot;, которые, даже устраняя проблему в краткосрочной перспективе, создают проблемы и плохие последствия в дальнейшем. Они порождают необходимость обхода проблемы и дестабилизируют всю структуру и реализацию.</p><p>Давайте рассмотрим список шаблонов, которые должны стать частью вашего инструментария для проектов на Vue 3.</p><h2 id="краткии-справочныи-список-шаблонов" tabindex="-1">Краткий справочный список шаблонов <a class="header-anchor" href="#краткии-справочныи-список-шаблонов" aria-label="Permalink to &quot;Краткий справочный список шаблонов&quot;">​</a></h2><p>Шаблоны классифицируются в зависимости от типа функции или проблемы, которую они решают. Существует множество шаблонов в зависимости от контекста, языка и архитектуры системы. Вот неполный список шаблонов, которые мы будем использовать в этой книге и которые, по моему опыту, чаще всего встречаются в приложениях на Vue:</p><h4 id="порождающие-шаблоны" tabindex="-1">Порождающие шаблоны <a class="header-anchor" href="#порождающие-шаблоны" aria-label="Permalink to &quot;Порождающие шаблоны&quot;">​</a></h4><p>Они касаются подхода к созданию классов, объектов и структур данных:</p><ul><li>Шаблон Singleton</li><li>Шаблон Dependency injection</li><li>Шаблон Factory</li></ul><h4 id="поведенческие-шаблоны" tabindex="-1">Поведенческие шаблоны <a class="header-anchor" href="#поведенческие-шаблоны" aria-label="Permalink to &quot;Поведенческие шаблоны&quot;">​</a></h4><p>Они касаются взаимодействия между объектами, компонентами и другими элементами приложения:</p><ul><li>Шаблон Observer</li><li>Шаблон Command</li></ul><h4 id="структурные-шаблоны" tabindex="-1">Структурные шаблоны <a class="header-anchor" href="#структурные-шаблоны" aria-label="Permalink to &quot;Структурные шаблоны&quot;">​</a></h4><p>Они предоставляют шаблоны, которые влияют на дизайн вашего приложения и взаимоотношения между компонентами:</p><ul><li>Шаблон Proxy</li><li>Шаблон Decorator</li><li>Шаблон Façade</li></ul><h4 id="асинхронные-шаблоны" tabindex="-1">Асинхронные шаблоны <a class="header-anchor" href="#асинхронные-шаблоны" aria-label="Permalink to &quot;Асинхронные шаблоны&quot;">​</a></h4><p>Они работают с потоком данных и процессов с асинхронными запросами и событиями в однопоточных приложениях (широко используются в веб-приложениях):</p><ul><li>Шаблон Callbacks</li><li>Шаблон Promises</li></ul><p>Ни в коем случае этот список шаблонов не является полным. Существует гораздо больше шаблонов и классификаций, и этому вопросу посвящена целая библиотека. Стоит отметить, что описание и применение некоторых из них может отличаться в разных литературах, а также существует некоторое дублирование в зависимости от контекста и реализации.</p><p>После такого знакомства с шаблонами проектирования давайте рассмотрим их подробнее на примерах.</p><h3 id="шаблон-singleton" tabindex="-1">Шаблон Singleton <a class="header-anchor" href="#шаблон-singleton" aria-label="Permalink to &quot;Шаблон Singleton&quot;">​</a></h3><p>Это очень распространенный шаблон в JavaScript и, возможно, один из самых важных, если не самый важный. Основная концепция определяет, что экземпляр одного объекта должен существовать только один раз во всем приложении, и все ссылки и вызовы функций осуществляются через этот объект. Синглтон может выступать в качестве шлюза для доступа к ресурсам, библиотекам и данным.</p><h4 id="когда-его-использовать" tabindex="-1">Когда его использовать <a class="header-anchor" href="#когда-его-использовать" aria-label="Permalink to &quot;Когда его использовать&quot;">​</a></h4><p>Вот краткое эмпирическое правило, позволяющее понять, когда следует применять этот шаблон:</p><ul><li>Когда необходимо убедиться, что доступ к ресурсу осуществляется только через один шлюз, например, к глобальному состоянию приложения</li><li>Когда необходимо инкапсулировать или упростить поведение, или взаимодействие (используется в сочетании с другими шаблонами). Например, объект доступа к API.</li><li>Когда <em>затраты</em> на многочисленные инстанцирования являются большими. Например, создание web workers.</li></ul><h4 id="реализация" tabindex="-1">Реализация <a class="header-anchor" href="#реализация" aria-label="Permalink to &quot;Реализация&quot;">​</a></h4><p>Существует множество способов применения этого шаблона в JavaScript. В некоторых случаях реализация из других языков переносится в JavaScript, часто следуя примерам Java с использованием метода <strong>getInstance()</strong> для получения синглтона. Однако существуют более эффективные способы реализации этого шаблона в JavaScript. Рассмотрим их далее.</p><h5 id="метод-1" tabindex="-1">Метод 1 <a class="header-anchor" href="#метод-1" aria-label="Permalink to &quot;Метод 1&quot;">​</a></h5><p>Самый простой способ - через модуль, экспортирующий обычный объектный литерал или <strong>JavaScript Object Notation</strong> (<strong>JSON</strong>), который является статическим объектом:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> my_singleton</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // Код реализации здесь...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> my_singleton;</span></span></code></pre></div><p>После этого вы можете импортировать этот модуль в другие модули и всегда иметь один и тот же объект. Это работает потому, что бандлеры и браузеры достаточно умны, чтобы избежать повторения импорта, поэтому, если этот объект был импортирован в первый раз, он будет игнорировать следующие запросы. Если не использовать бандлер, то реализация JavaScript в ES6 также определяет, что модули являются синглтонами.</p><h5 id="метод-2" tabindex="-1">Метод 2 <a class="header-anchor" href="#метод-2" aria-label="Permalink to &quot;Метод 2&quot;">​</a></h5><p>Этот метод создает класс, а затем, при первом инстанцировании, сохраняет ссылку на него для последующих обращений. Для того чтобы это работало, мы используем переменную (традиционно называемую <strong>_instance</strong>) из класса и сохраняем ссылку на экземпляр в конструкторе. В последующих вызовах мы проверяем, существует ли значение <strong>_instance</strong>, и если да, то возвращаем его. Вот код:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> myClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (myClass._instance) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> myClass._instance;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    myClass._instance </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> myClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><p>Второй метод может быть более привычным для разработчиков других языков. Обратите внимание, что мы также экспортируем новый экземпляр класса, а не непосредственно сам класс. Таким образом, инвокеру не придется каждый раз вспоминать об инстанцировании класса, а код будет таким же, как и в <em>методе 1</em>. Этот вариант использования необходимо согласовать с вашей командой, чтобы избежать различных реализаций.</p><p>Затем инвокер может вызывать методы каждого из них напрямую (при условии, что синглтон имеет функцию/метод с названием <strong>myFunction()</strong>):</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> my_method1_singleton </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;./singleton-json&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> my_method2_singleton </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;./singleton-class&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;В обоих случаях инстанцирования нет!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">my_method1_singleton.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">myFunction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">my_method2_singleton.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">myFunction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><p>Шаблон синглтон чрезвычайно полезен, хотя он редко существует <em>в изоляции</em>. Часто мы используем синглтоны, чтобы обернуть реализацию других шаблонов и обеспечить единую точку доступа. В наших примерах мы будем использовать этот шаблон довольно часто.</p><h3 id="шаблон-dependency-injection-инъекция-зависимостеи" tabindex="-1">Шаблон Dependency injection (инъекция зависимостей) <a class="header-anchor" href="#шаблон-dependency-injection-инъекция-зависимостеи" aria-label="Permalink to &quot;Шаблон Dependency injection (инъекция зависимостей)&quot;">​</a></h3><p>Этот шаблон просто утверждает, что зависимости для класса или функции предоставляются в качестве входных данных, например, в виде параметров, свойств или других типов реализаций. Это простое утверждение открывает очень широкий спектр возможностей. Возьмем, к примеру, класс, работающий с <strong>IndexedDB API</strong> браузера через класс абстракции. Подробнее об API IndexedDB мы узнаем в главе 7, <em>Управление потоками данных</em>, а пока остановимся на зависимой части.</p><p>Предположим, что файл <strong>dbManager.js</strong> экспортирует объект, который обрабатывает операции с базой данных, а объект <strong>projects</strong> обрабатывает CRUD-операции для таблицы (или коллекции) <code>projects</code>. Без использования инъекции зависимостей получится что-то подобное этому:</p><h4 id="chapter-2-dependency-injection-1-js" tabindex="-1">./chapter 2/dependency-injection-1.js <a class="header-anchor" href="#chapter-2-dependency-injection-1-js" aria-label="Permalink to &quot;./chapter 2/dependency-injection-1.js&quot;">​</a></h4><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dbManager </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;dbManager&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> projects</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  getAllProjects</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dbManager.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getAll</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;projects&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> projects;</span></span></code></pre></div><p>Предыдущий код демонстрирует &quot;нормальный&quot; подход, когда мы импортируем зависимости в начале файла и затем используем их в коде. Теперь давайте изменим этот же код, чтобы использовать инъекцию зависимостей:</p><h4 id="chapter-2-dependency-injection-2-js" tabindex="-1">./chapter 2/dependency-injection-2.js <a class="header-anchor" href="#chapter-2-dependency-injection-2-js" aria-label="Permalink to &quot;./chapter 2/dependency-injection-2.js&quot;">​</a></h4><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> projects</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  getAllProjects</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">dbManager</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dbManager.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getAll</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;projects&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> projects;</span></span></code></pre></div><p>Как видите, основное отличие заключается в том, что <strong>dbManager</strong> теперь передается в качестве параметра функции. Это то, что называется <strong>инъекцией</strong>. Это открывает множество способов управления зависимостями и в то же время отодвигает жесткое кодирование зависимостей вверх по дереву реализации. Это делает данный класс очень удобным для повторного использования, по крайней мере, до тех пор, пока зависимость соответствует ожидаемому API.</p><p>Приведенный пример не является единственным способом инъекции зависимости. Можно, например, присвоить ее внутреннему свойству объекта. Например, если бы файл <strong>projects.js</strong> был реализован с использованием подхода, основанного на свойствах, то он выглядел бы следующим образом:</p><h4 id="chapter-2-dependency-injection-3-js" tabindex="-1">./chapter 2/dependency-injection-3.js <a class="header-anchor" href="#chapter-2-dependency-injection-3-js" aria-label="Permalink to &quot;./chapter 2/dependency-injection-3.js&quot;">​</a></h4><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> projects</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  dbManager,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  getAllProjects</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.dbManager.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getAll</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;projects&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> projects;</span></span></code></pre></div><p>В этом случае инвокер объекта (кстати, синглтона) должен знать об этом свойстве и присвоить его перед вызовом любой из своих функций. Вот пример того, как это будет выглядеть:</p><h4 id="chapter-2-dependency-injection-4-js" tabindex="-1">./chapter 2/dependency-injection-4.js <a class="header-anchor" href="#chapter-2-dependency-injection-4-js" aria-label="Permalink to &quot;./chapter 2/dependency-injection-4.js&quot;">​</a></h4><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> projects </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;projects.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dbManager </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;dbManager.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">projects.dbManager </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dbManager;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">projects.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getAllProjects</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><p>Но такой подход не рекомендуется. Вы можете видеть, что он нарушает принцип инкапсуляции, поскольку мы напрямую присваиваем свойство объекту. Кроме того, это не похоже на чистый код, даже если это корректный код.</p><p>Передача зависимостей по одной функции за раз также не рекомендуется. Итак, какой же подход лучше? Это зависит от реализации:</p><ul><li>В классе удобно требовать наличие зависимостей в конструкторе (а если они не найдены, то выдавать ошибку)</li><li>В обычном JSON-объекте удобно предоставить функцию для явного задания зависимости и позволить объекту самому решать, как ее использовать</li></ul><p>Этот последний подход также рекомендуется для передачи зависимости после инстанцирования объекта, когда зависимость не готова на момент реализации.</p><p>Приведем пример кода для первого пункта, упомянутого в предыдущем списке:</p><h4 id="chapter-2-dependency-injection-5-js" tabindex="-1">./chapter 2/dependency-injection-5.js <a class="header-anchor" href="#chapter-2-dependency-injection-5-js" aria-label="Permalink to &quot;./chapter 2/dependency-injection-5.js&quot;">​</a></h4><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Projects</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">dbManager</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">dbManager) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      throw</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Dependency missing&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.dbManager </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dbManager;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>В конструкторе мы объявляем ожидаемый параметр со значением по умолчанию. Если зависимость не предоставлена, мы выбрасываем ошибку. В противном случае мы присваиваем ее внутреннему приватному атрибуту для использования экземпляром. В данном случае инвокер должен выглядеть следующим образом:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Projects - это класс</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Projects </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;projects.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dbManager </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;dbManager.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">try</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> projects</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Projects</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(dbManager);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // Обработчик ошибок здесь</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>В альтернативной реализации мы могли бы иметь функцию, которая, по сути, делает то же самое, получая зависимость и присваивая ее приватному атрибуту:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> projects </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;projects.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dbManager </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;dbManager.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">projects.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setDBManager</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(dbManager);</span></span></code></pre></div><p>Этот подход лучше, чем прямое присвоение внутреннего атрибута, но все равно нужно не забыть выполнить присвоение перед использованием любых методов объекта.</p><div class="tip custom-block"><p class="custom-block-title">Совет из Лучших практик</p><p>Какой бы подход вы ни использовали для инъекции зависимостей, он должен оставаться неизменным во всей вашей кодовой базе.</p></div><p>Вы, наверное, заметили, что мы в основном сосредоточились на объектах. Как вы уже догадались, передача зависимости в функцию - это то же самое, что и передача другого параметра, поэтому она не заслуживает особого внимания.</p><p>В данном примере ответственность за реализацию зависимости просто перенесена на другой класс в иерархии. Но что если реализовать шаблон singleton для обработки всех или большинства зависимостей в нашем приложении? Таким образом, мы могли бы просто делегировать загрузку зависимостей одному классу или объекту в определенный момент жизненного цикла нашего приложения. Но как это реализовать? Нам понадобится следующее:</p><ul><li>Метод для регистрации зависимости</li><li>Метод для получения зависимости по имени</li><li>Структура для хранения ссылок на каждую зависимость</li></ul><p>Применим это на практике и создадим очень <em>наивную</em> реализацию такого синглтона. Пожалуйста, помните, что это академическое упражнение, поэтому мы не рассматриваем проверку ошибок, снятие с регистрации, или другие соображения:</p><h4 id="chapter-2-dependency-injection-6-js" tabindex="-1">./chapter 2/dependency-injection-6.js <a class="header-anchor" href="#chapter-2-dependency-injection-6-js" aria-label="Permalink to &quot;./chapter 2/dependency-injection-6.js&quot;">​</a></h4><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> dependencyService</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {                         </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  dependencies: {}, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 2</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  provide</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">dependency</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {                     </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 3</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.dependencies[name] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dependency;       </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 4</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;                                </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 5</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  inject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {                                  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 6</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.dependencies[name] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">??</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;     </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 7</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dependencyService;</span></span></code></pre></div><p>После этой минимальной реализации рассмотрим каждую строку по строковому комментарию:</p><ol><li>Мы создаем простой объектный литерал JavaScript как синглтон.</li><li>Объявляем пустой объект для использования в качестве словаря для хранения зависимостей по именам.</li><li>Функция <strong>provide</strong> позволяет нам зарегистрировать зависимость по имени.</li><li>Здесь мы просто используем имя в качестве имени поля и присваиваем зависимость, переданную в качестве аргумента (заметьте, мы не проверяем уже существующие имена и т.д.).</li><li>Здесь мы возвращаем исходный объект, в основном для удобства, чтобы можно было выстроить цепочку вызовов.</li><li>Функция <strong>inject</strong> принимает имя, зарегистрированное в <strong>provide</strong> функции.</li><li>Мы возвращаем зависимость или <strong>null</strong>, если она не найдена.</li></ol><p>Получив синглтон, мы можем использовать его во всем приложении для распределения зависимостей по мере необходимости. Для этого нам нужен родительский объект, чтобы импортировать их и заполнить сервис. Вот пример того, как это может выглядеть:</p><h4 id="chapter-2-dependency-injection-7-js" tabindex="-1">./chapter 2/dependency-injection-7.js <a class="header-anchor" href="#chapter-2-dependency-injection-7-js" aria-label="Permalink to &quot;./chapter 2/dependency-injection-7.js&quot;">​</a></h4><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dependencyService </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;./dependency-injection-6&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> myDependency1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;myFile1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> myDependency2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;myFile2&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dbManager </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;dbManager&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">dependencyService</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">provide</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;dependency1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, myDependency1);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">provide</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;dependency2&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, myDependency2);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">provide</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;dbManager&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, dbManager);</span></span></code></pre></div><p>Как видно, модуль имеет жестко закодированные зависимости, и его работа заключается в загрузке их в объект <strong>dependencyService</strong>. Затем зависимой функции или объекту достаточно импортировать сервис и получить нужную зависимость по имени регистрации следующим образом:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dependencyService </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;./dependency-injection-6&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> dbManager</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dependencyService.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">inject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;dbManager&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>Этот подход действительно создает тесную связь между компонентами, но он приведен здесь в качестве справочного материала. Его преимущество заключается в том, что мы можем контролировать все зависимости в одном месте, так что преимущества в обслуживании могут быть значительными.</p><p>Выбор имен для методов объекта <strong>dependencyService</strong> также не случаен: они совпадают с теми, что используются в Vue 3 внутри иерархии компонента. Это очень удобно для реализации некоторых шаблонов проектирования пользовательского интерфейса. Более подробно мы рассмотрим это в главе 4, <em>Композиция пользовательского интерфейса с компонентами</em> и Главе 7, <em>Управление потоком данных</em>.</p><p>Как видите, этот шаблон очень важен и реализован в Vue 3 с помощью функций <strong>provide</strong>/<strong>inject</strong>. Это отличное дополнение к нашему набору инструментов, но это еще не все. Давайте перейдем к следующему.</p><h3 id="шаблон-factory-фабрика" tabindex="-1">Шаблон factory (фабрика) <a class="header-anchor" href="#шаблон-factory-фабрика" aria-label="Permalink to &quot;Шаблон factory (фабрика)&quot;">​</a></h3><p>Шаблон фабрики предоставляет нам способ создания объектов без создания прямых зависимостей. Он работает через функцию, которая, основываясь на входных данных, возвращает инстанцированный объект. Использование такой реализации будет осуществляться через общий или стандартный интерфейс.</p><p>Например, рассмотрим два класса: <strong>Circle</strong> и <strong>Square</strong>. Оба реализуют один и тот же метод <strong>draw()</strong>, который рисует фигуру на холсте. Тогда функция <strong>фабрики</strong> будет работать примерно так:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createShape</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  switch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (type) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    case</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;circle&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Circle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    case</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;square&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Square</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  shape1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createShape</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;circle&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> shape2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createShape</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;square&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">shape1.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">draw</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">shape2.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">draw</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><p>Этот метод довольно популярен, особенно в сочетании с другими шаблонами, что мы неоднократно увидим в этой книге.</p><h3 id="шаблон-observer-наблюдатель" tabindex="-1">Шаблон Observer (наблюдатель) <a class="header-anchor" href="#шаблон-observer-наблюдатель" aria-label="Permalink to &quot;Шаблон Observer (наблюдатель)&quot;">​</a></h3><p>Шаблон &quot;наблюдатель&quot; очень полезен и является одной из основ реактивного фреймворка. Он определяет отношения между объектами, в которых один из них наблюдает (<strong>субъект</strong>) за изменениями или событиями, а другой (другие) уведомляется об этих изменениях (<strong>наблюдатели</strong>). Наблюдатели также называются <strong>слушателями</strong>. Вот графическое представление:</p><p><img src="`+l+'" alt="image"></p><p>Рисунок 2.3 - Субъект выдает событие и оповещает наблюдателей.</p><p>Как видно из рисунка, субъект выдает событие для оповещения наблюдателей. Субъект сам определяет, какие события и параметры он будет <strong>опубликовывать</strong>. Тем временем наблюдатели <strong>подписываются</strong> на каждое событие, регистрируя функцию у издателя. Именно поэтому данный шаблон часто называют шаблоном <strong>pub/sub</strong>, и он может иметь несколько вариаций.</p><p>При рассмотрении реализации этого шаблона важно обратить внимание на кардинальность публикации: <strong>1</strong> событие на <strong>0..N</strong> наблюдателей (функций). Это означает, что субъект должен реализовать, помимо своего основного назначения, функциональность по публикации событий и отслеживанию подписчиков. Поскольку это нарушает один или два принципа проектирования (разделение забот, единая ответственность и т.д.), принято выносить эту функциональность в средний объект. В этом случае предыдущий проект изменяется, добавляя средний слой:</p><p><img src="'+k+`" alt="image"></p><p>Рисунок 2.4 - Реализация наблюдателя со средним объектом диспетчера.</p><p>Этот средний объект, иногда называемый &quot;<strong>диспетчером событий</strong>&quot;, включает в себя базовую функциональность по регистрации наблюдателей, получению событий от субъекта и их отправке наблюдателям. Он также выполняет некоторые действия по очистке, когда наблюдатель перестает наблюдать. Давайте рассмотрим эти понятия на примере простой и наивной реализации диспетчера событий на обычном JavaScript:</p><h4 id="chapter-2-observer-1-js" tabindex="-1">./chapter 2/Observer-1.js <a class="header-anchor" href="#chapter-2-observer-1-js" aria-label="Permalink to &quot;./chapter 2/Observer-1.js&quot;">​</a></h4><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ObserverPattern</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.events </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {};                                       </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  on</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event_name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fn</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {}) {                             </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 2</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.events[event_name]) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.events[event_name] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.events[event_name].</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fn);                       </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 3</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  emit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event_name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {                                    </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 4</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.events[event_name]) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, l </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.events[event_name].</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> l; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.events[event_name][i](data);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  off</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event_name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">fn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {                                       </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 5</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.events[event_name].</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">indexOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fn);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.events[event_name].</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">splice</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Представленная реализация, опять же, является наивной. В ней нет необходимой обработки ошибок и крайних случаев, которые можно использовать в производстве, но есть основы диспетчера событий. Давайте рассмотрим ее построчно:</p><ol><li>В конструкторе мы объявляем объект для использования в качестве внутреннего словаря для событий.</li><li>Метод <strong>on</strong> позволяет наблюдателям зарегистрировать свои функции. В этой строке, если событие не инициализировано, мы создаем пустой массив.</li><li>В этой строке мы просто кладем функцию в массив (как я уже говорил, это наивная реализация, так как мы не проверяем, например, дубликаты).</li><li>Метод <strong>emit</strong> позволяет субъекту опубликовать событие по его имени и передать ему некоторые данные. Здесь мы пробегаемся по массиву и выполняем каждую функцию, передавая в качестве параметра полученные данные.</li><li>Метод <strong>off</strong> необходим для того, чтобы снять с регистрации функцию, если она не используется (см. принцип <em>keep it clean</em>, приведенный ранее в этой главе).</li></ol><p>Для того чтобы данная реализация работала, каждый наблюдатель и субъект должны ссылаться на одну и ту же реализацию <strong>ObserverClass</strong>. Самый простой способ обеспечить это - реализовать его через шаблон <em>синглтон</em>. После импорта каждый наблюдатель регистрируется в диспетчере с помощью следующей строки:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dispatcher </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;ObserverClass.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// a singleton</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">dispatcher.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">on</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;event_name&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, myFunction);</span></span></code></pre></div><p>После этого субъект испускает событие и передает данные следующими строками:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dispatcher </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;ObserverClass.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// a singleton</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">dispatcher.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">emit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;event_name&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, data);</span></span></code></pre></div><p>И наконец, когда наблюдателю больше не нужно следить за объектом, необходимо очистить ссылку с помощью метода <strong>off</strong>:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">dispatcher.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">off</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;имя_события&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, myFunction);</span></span></code></pre></div><p>Существует большое количество крайних случаев и элементов управления, которые мы здесь не рассмотрели, и вместо того, чтобы изобретать велосипед, я предлагаю использовать готовые решения для этих случаев. В нашей книге мы будем использовать одно из них под названием <strong>mitt</strong> (<a href="https://www.npmjs.com/package/mitt" target="_blank" rel="noreferrer">https://www.npmjs.com/package/mitt</a>). Оно имеет те же методы, что и в нашем примере. Как устанавливать упакованные зависимости, мы рассмотрим в главе 3, <em>Установка рабочего проекта</em>.</p><h3 id="шаблон-command-команда" tabindex="-1">Шаблон Command (команда) <a class="header-anchor" href="#шаблон-command-команда" aria-label="Permalink to &quot;Шаблон Command (команда)&quot;">​</a></h3><p>Этот шаблон очень полезен и прост для понимания и реализации. Вместо того чтобы сразу выполнять функцию, основная концепция заключается в создании объекта или структуры с информацией, необходимой для выполнения. Затем этот пакет данных (<strong>команда</strong>) делегируется другому объекту, который будет выполнять исполнение в соответствии с некоторой логикой его обработки. Например, команды могут быть сериализованы и поставлены в очередь, запланированы, отменены, сгруппированы и преобразованы. Вот графическое представление этого шаблона с необходимыми частями:</p><p><img src="`+e+`" alt="image"></p><p>Рисунок 2.5 - Графическая реализация командного шаблона</p><p>На схеме показано, как клиенты передают свои команды <strong>инвокеру</strong>. Обычно инвокер реализует некую очередь или массив задач для обработки команд, а затем направляет их выполнение соответствующему <strong>приемнику</strong>. Если есть какие-либо данные для возврата, он также возвращает их соответствующему клиенту.</p><p>Также часто инвокер присоединяет к команде дополнительные данные для отслеживания клиентов и получателей, особенно в случае асинхронного выполнения. Это также обеспечивает единую точку &quot;входа&quot; в приемники и отделяет от них &quot;клиентов&quot;.</p><p>Снова поработаем над наивной реализацией класса <strong>Invoker</strong>:</p><h4 id="chapter-2-command-1-js" tabindex="-1">./chapter 2/Command-1.js <a class="header-anchor" href="#chapter-2-command-1-js" aria-label="Permalink to &quot;./chapter 2/Command-1.js&quot;">​</a></h4><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> CommandInvoker</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  addCommand</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">command_data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {                              </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 1</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ... реализация очереди здесь</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  runCommand</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">command_data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {                              </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 2</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    switch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (command_data.action) { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 3</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      case</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;eat&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // ... вызываем получателя здесь</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        break</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      case</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;code&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // ... вызываем получателя здесь</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        break</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      case</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;repeat&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // ... вызываем получателя здесь</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        break</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>В предыдущем коде мы построчно реализовали пример того, каким должен быть <strong>инвокер</strong>:</p><ol><li>В <strong>Invoker</strong> раскрывается метод для добавления команд в объект. Это необходимо только в том случае, если команды будут каким-то образом ставиться в очередь, сериализовываться или обрабатываться в соответствии с некоторой логикой.</li><li>Эта строка выполняет команду в соответствии с полем <strong>action</strong>, содержащимся в параметре <strong>command_data</strong>.</li><li>На основании поля <strong>действие</strong> <em>invoker</em> направляет выполнение в соответствующий приемник.</li></ol><p>Реализовать логику маршрутизации выполнения можно разными способами. Важно отметить, что данный шаблон может быть реализован в более широком масштабе в зависимости от контекста. Например, инвокер может находиться даже не в клиентском веб-приложении, а на сервере или на другой машине. Реализацию этого шаблона мы увидим в главе 8, <em>Многопоточность с Web Workers</em>, где мы используем этот шаблон для обработки задач между различными потоками и разгрузки главного потока (в котором работает Vue 3).</p><h3 id="шаблон-proxy" tabindex="-1">Шаблон Proxy <a class="header-anchor" href="#шаблон-proxy" aria-label="Permalink to &quot;Шаблон Proxy&quot;">​</a></h3><p>Определение этого шаблона вытекает непосредственно из его названия, поскольку слово &quot;прокси&quot; означает что-то или кого-то, кто действует от имени другого, как если бы это было одно и то же. Довольно многословно, но это поможет вам запомнить его.</p><p>Давайте рассмотрим пример, чтобы прояснить, как это работает. Нам понадобятся как минимум три сущности (компонента, объекта и т.д.):</p><ul><li>Сущность <strong>клиент</strong>, которой необходимо получить доступ к API целевой сущности</li><li>А <strong>целевая</strong> сущность, которая предоставляет некий API</li><li>Объект <strong>прокси</strong>, который занимает промежуточное положение и предоставляет тот же API, что и целевой объект, одновременно перехватывая каждое сообщение от клиента и передавая его целевому объекту</li></ul><p>Взаимосвязь между этими объектами можно представить графически следующим образом:</p><p><img src="`+r+`" alt="image"></p><p>Рисунок 2.6 - Прокси-объект раскрывает тот же API, что и целевой.</p><p>Ключевым фактором данного шаблона является то, что прокси ведет себя и предоставляет тот же API, что и целевой объект, причем таким образом, что клиент не знает или не должен знать, что он имеет дело с прокси, а не с целевым объектом напрямую. Итак, зачем нам это нужно? Есть много веских причин, например, следующие:</p><ul><li>Вам необходимо сохранить оригинальный немодифицированный API, но в то же время: <ul><li>Необходимо обрабатывать входные или выходные данные для клиента</li><li>Необходимо перехватывать каждый вызов API для добавления внутренней функциональности, например, операций обслуживания, повышения производительности, проверка ошибок и валидация</li><li>Цель является дорогим ресурсом, поэтому прокси может реализовать логику для использования его операций (например, кэш)</li></ul></li><li>Вам необходимо изменить клиента или цель, но вы не можете изменить API</li><li>Вам необходимо поддерживать обратную совместимость</li></ul><p>Есть и другие причины, с которыми вы можете столкнуться, но я надеюсь, что теперь вы видите, как это может быть полезно. Будучи шаблоном, этот шаблон может быть реализован на различных уровнях, от простого объектного прокси до полноценного приложения или сервера. Он довольно часто используется при частичном обновлении системы или приложения.</p><p>На более низком уровне JavaScript даже содержит встроенный конструктор для проксирования объектов, который Vue 3 использует для создания реактивности.</p><p>В главе 1, <em>The Vue 3 Framework</em>, мы рассмотрели варианты реактивности с помощью <strong>ref()</strong>, но в новой версии Vue также появилась другая альтернатива для сложных структур, называемая <strong>reactive()</strong>. В первом случае используются методы <code>pub/sub</code>(шаблон наблюдателя!), а во втором - нативные обработчики прокси (этот шаблон!). Рассмотрим на примере наивной частичной реализации, как может работать эта нативная реализация.</p><p>В этом простом примере мы заставим объект с реактивными свойствами автоматически преобразовывать градусы Цельсия в градусы Фаренгейта и обратно с помощью <strong>Proxy</strong> объекта:</p><h4 id="chapter-2-proxy-1-js" tabindex="-1">./chapter 2/proxy-1.js <a class="header-anchor" href="#chapter-2-proxy-1-js" aria-label="Permalink to &quot;./chapter 2/proxy-1.js&quot;">​</a></h4><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> temperature</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { celsius: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, fahrenheit: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> };                     </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> handler</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 2</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">target</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {                                   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 3</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    target[key] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value;                                    </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 4</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    switch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (key) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      case</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;celsius&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        target.fahrenheit </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> calculateFahrenheit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 5</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        break</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      case</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;fahrenheit&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        target.celsius </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> calculateCelsius</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        break</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">target</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> target[key]; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 6</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">degrees </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Proxy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(temperature, handler);                      </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 7</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Вспомогательные функции</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> calculateCelsius</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">fahrenheit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (fahrenheit </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1.8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> calculateFahrenheit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">celsius</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (celsius </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1.8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">degrees.celsius </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 25</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 8</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(degrees);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Выводится в консоль:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// {celsius: 25, fahrenheit: 77}                                    //9</span></span></code></pre></div><p>Давайте рассмотрим код построчно, чтобы увидеть, как это работает:</p><ol><li>В этой строке мы объявляем объект <strong>temperature</strong>, который будет нашей целью для проксирования. Мы инициализируем два его свойства одинаковым преобразованным значением.</li><li>Объявляем объект <strong>handler</strong>, который будет нашим прокси для объекта temperature.</li><li>Функция <strong>set</strong> в прокси-обработчике получает три аргумента: целевой объект, ключ, на который ссылаются, и значение, которое пытаются присвоить. Обратите внимание, что я говорю &quot;попытка&quot;, поскольку операция была перехвачена прокси-сервером.</li><li>В этой строке мы выполняем присваивание, как и предполагалось, свойству объекта. Здесь мы могли бы выполнить другие преобразования или логику, например, проверку или вызвать событие (снова шаблон Observer!).</li><li>Обратите внимание, как мы используем переключатель для фильтрации интересующих нас имен свойств. Когда ключом является <strong>celsius</strong>, мы вычисляем и присваиваем значение в градусах Фаренгейта. Обратное происходит, когда мы получаем задание для <strong>градусов Фаренгейта</strong>. Вот здесь-то и проявляется <strong>реактивность</strong>.</li><li>Для функции <strong>get</strong>, по крайней мере в этом примере, мы просто возвращаем запрошенное значение. В том виде, в котором это реализовано, это было бы то же самое, как если бы мы пропустили функцию <strong>getter</strong>. Однако именно здесь в качестве примера мы можем оперировать и преобразовывать возвращаемое значение, поскольку эта операция также перехватывается.</li><li>И наконец, в строке 7 мы объявляем объект <strong>degrees</strong> в качестве прокси для <strong>temperature</strong> с обработчиком.</li><li>В этой строке мы проверяем реактивность, присваивая члену объекта <strong>degrees</strong> значение в <em>Celsius</em> , как это обычно делается для любого другого объекта.</li><li>Когда мы выводим объект <strong>degrees</strong> на консоль, мы замечаем, что свойство <strong>fahrenheit</strong> автоматически обновилось.</li></ol><p>Это довольно ограниченный и простой пример того, как работает и применяется конструктор <strong>Proxy()</strong>, реализующий данный шаблон. Vue 3 имеет более сложный подход к реактивности и отслеживанию зависимостей, используя шаблоны proxy и observer. Тем не менее, это дает нам хорошее представление о том, какой подход происходит за кулисами, когда мы видим обновление HTML в реальном времени на наших глазах.</p><p>Концепция проксирования между клиентом и объектом связана со следующими двумя шаблонами: <em>декоратор и фасад</em>, поскольку они также являются своего рода реализацией прокси. Отличительной особенностью является то, что прокси сохраняет тот же API, что и исходный целевой объект.</p><h3 id="шаблон-decorator-декоратор" tabindex="-1">Шаблон Decorator (декоратор) <a class="header-anchor" href="#шаблон-decorator-декоратор" aria-label="Permalink to &quot;Шаблон Decorator (декоратор)&quot;">​</a></h3><p>На первый взгляд этот шаблон может показаться очень похожим на шаблон <em>прокси</em>, и это действительно так, однако он добавляет несколько отличительных особенностей, которые выделяют его из общего ряда.</p><p>В нем есть те же подвижные части, что и в прокси, то есть <strong>клиент</strong>, <strong>цель</strong> и <strong>декоратор</strong> между ними, который реализует тот же интерфейс, что и цель (да, точно так же, как и в прокси). Однако если в шаблоне <em>Proxy</em> перехваченные вызовы API в основном работают с данными и внутренним обслуживанием, то декоратор расширяет функциональность исходного объекта, делая его более функциональным. Это и есть фактор, который их разделяет.</p><p>В примере с прокси можно заметить, что дополнительной функциональностью стала <em>внутренняя реактивность</em>, позволяющая синхронизировать градусы в каждой шкале. Когда вы изменяете одну из них, она внутренне и автоматически обновляет другую. В шаблоне декоратора прокси-объект выполняет дополнительные операции до, во время или после выполнения вызова API к целевому объекту. Как и в шаблоне proxy, все это прозрачно для клиентского объекта.</p><p>Например, опираясь на предыдущий код, представим, что теперь мы хотим регистрировать каждый вызов API определенного объекта, сохраняя при этом его функциональность. Графически это будет выглядеть следующим образом:</p><p><img src="`+E+`" alt="image"></p><p>Рисунок 2.7 - Пример декоратора, дополняющего цель функцией протоколирования.</p><p>Здесь то, что сначала было простым прокси, теперь, в результате выполнения скромного вызова логирования, превратилось в декоратор. В коде нам достаточно добавить эту строку перед концом метода <strong>set()</strong> (при условии, что существует также функция с именем <strong>getTimeStamp()</strong>):</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getTimeStamp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span></code></pre></div><p>Конечно, это простой пример, просто чтобы пояснить суть. В реальном мире декораторы очень полезны для добавления функциональности в приложение без необходимости переписывать логику или значительные части кода. Кроме того, декораторы могут быть <em>штабелируемыми</em> (<em>stackable</em>) или <em>цепляемыми</em> (<em>chainable</em>), что означает, что при необходимости можно создавать &quot;декораторы для декораторов&quot;, каждый из которых будет представлять собой один шаг добавления функциональности, сохраняющий тот же API целевого объекта.</p><p>И вот так мы начинаем входить в границы шаблона <strong>middleware</strong>, но в этой книге мы его рассматривать не будем. В любом случае, идея этого шаблона заключается в создании слоев промежуточных функций с определенным API, каждая из которых выполняет одно действие, но с той разницей, что на любом шаге можно принять решение о прерывании операции, и тогда целевой объект может быть вызван, а может и нет. Но это уже другая история... Вернемся к декораторам.</p><p>Ранее в этой книге мы уже упоминали, что компоненты Vue 3 не имеют наследования, как обычные классы JavaScript, реализуемые путем расширения друг от друга. Вместо этого мы можем использовать шаблон декораторов в компонентах для добавления функциональности или изменения внешнего вида. Сейчас рассмотрим краткий пример, поскольку более подробно компоненты и проектирование пользовательского интерфейса будут рассмотрены в главе 4, <em>Композиция пользовательского интерфейса с компонентами</em>.</p><p>Рассмотрим простейший компонент, отображающий скромный тег <strong>h1</strong> с заголовком, который получает на вход следующие данные:</p><h4 id="chapter-2-decorator-1-vue" tabindex="-1">./chapter 2/decorator-1.vue <a class="header-anchor" href="#chapter-2-decorator-1-vue" aria-label="Permalink to &quot;./chapter 2/decorator-1.vue&quot;">​</a></h4><div class="language-vue vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setup</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> $props</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> defineProps</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;label&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]);          </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">h1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;{{ $props.label }}&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">h1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;                     //2</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">style</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> scoped</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">style</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>В этом простом компоненте в строке <code>//1</code> мы объявляем один входной элемент с именем <strong>label</strong>. Не стоит пока беспокоиться о синтаксисе, поскольку мы подробно рассмотрим это в главе 4, <em>Композиция пользовательского интерфейса с компонентами</em>. В строке <code>//2</code> мы интерполируем значение непосредственно внутри тегов <strong>h1</strong>, как и ожидалось.</p><p>Таким образом, чтобы создать декоратор для этого компонента, нам необходимо применить следующие простые правила:</p><ul><li>Он должен действовать от имени компонента (объекта)</li><li>Он должен использовать тот же API (входы, выходы, вызовы функций и т.д.)</li><li>Он должен дополнять функциональность или визуальное представление до, после или во время выполнения целевого API</li></ul><p>В связи с этим мы можем создать компонент-декоратор, который перехватывает атрибут label, немного изменяет его, а также модифицирует визуальный вид целевого компонента:</p><h4 id="chapter-2-decorator-2-vue" tabindex="-1">./chapter 2/decorator-2.vue <a class="header-anchor" href="#chapter-2-decorator-2-vue" aria-label="Permalink to &quot;./chapter 2/decorator-2.vue&quot;">​</a></h4><div class="language-vue vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setup</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> HeaderH1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;./decorator-1.vue&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> $props</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> defineProps</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;label&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]);               </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> style</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;color: purple !important;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                  //2</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">             &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">HeaderH1</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> :title</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;\`\${$props.label}!!!\`&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;        //3</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>В этом коде в строке <code>//1</code> видно, что мы сохраняем тот же интерфейс, что и у целевого компонента (который мы импортировали в предыдущей строке), затем в строке <code>//2</code> мы изменяем (дополняем) атрибут <strong>color</strong> , а в строке <code>//3</code> мы также изменяем данные, передаваемые целевому компоненту, добавляя три восклицательных знака. Выполнив эти простые задачи, мы сохранили условия для построения шаблона декоратора, экстраполированного на компоненты Vue 3. Совсем неплохо.</p><p>Декораторы очень полезны, но есть еще один прокси-подобный шаблон, который также очень распространен и удобен: шаблон фасада.</p><h3 id="шаблон-facade-фасад" tabindex="-1">Шаблон Façade (фасад) <a class="header-anchor" href="#шаблон-facade-фасад" aria-label="Permalink to &quot;Шаблон Façade (фасад)&quot;">​</a></h3><p>К настоящему времени вы, возможно, уже видели прогрессивный шаблон в этих, ну, шаблонах. Мы начали с прокси, действующего от имени другого объекта или сущности, дополнили его декораторами, сохранив при этом тот же API, и вот теперь настал черед шаблона façade.</p><p>Его задача, помимо функций прокси и декоратора, состоит в том, чтобы упростить API и скрыть за ним большую сложность. Итак, фасад располагается между клиентом и объектом, но теперь объект сложен - это система или даже несколько подсистем. Этот шаблон также используется для изменения API объекта или для ограничения его воздействия на клиента. Взаимодействие можно представить следующим образом:</p><p><img src="`+d+`" alt="image"></p><p>Рисунок 2.8 - Фасадный объект, упрощающий взаимодействие со сложным API или системой.</p><p>Как видите, основное назначение фасада - предложить более простой подход к сложному взаимодействию или API. Мы неоднократно будем использовать этот шаблон в наших примерах для упрощения нативных реализаций в браузере с помощью более удобных для разработчика подходов. Мы будем использовать библиотеки для инкапсуляции использования IndexedDB и создадим собственное упрощенное взаимодействие с web-workers в главе 8, <em>Многопоточность с Web Workers</em>.</p><p>Необходимо отметить, что вы уже видели этот шаблон в действии, поскольку он является одной из основополагающих концепций современных технологий. <em>Скрытие сложности</em> за простым интерфейсом (API) встречается повсеместно и является неотъемлемой частью веб-разработки. В конце концов, весь Интернет чрезвычайно сложен, в нем тысячи движущихся частей, а технология, с помощью которой создаются веб-страницы, близка к волшебству. Без этого шаблона мы бы до сих пор программировали с помощью нулей и единиц.</p><p>На практике вы будете добавлять уровни упрощения в свои собственные приложения, чтобы снизить сложность. Одним из способов сделать это является использование сторонних библиотек, предоставляющих упрощенный интерфейс. В следующих главах мы будем использовать некоторые из них, например, такие:</p><ul><li><strong>Axios</strong>: для обработки всех <strong>асинхронных JavaScript и XML</strong> (<strong>AJAX</strong>) взаимодействий с сервером</li><li><strong>DexieDB</strong>: Для работы с API к IndexedDB (локальной базе данных браузера)</li><li><strong>Mitt</strong>: Для создания конвейеров событий (мы упоминали об этом в шаблоне Observer)</li><li><strong>Vue 3</strong>: Для создания удивительных пользовательских интерфейсов</li></ul><p>В целом, для большинства нативных реализаций веб-технологий существуют библиотеки фасадов, которые хорошо протестированы. Разработчики очень хорошо умеют упрощать их и делиться кодом с другими, благодаря движению open source. Тем не менее, используя чужие модули, убедитесь, что они &quot;безопасны&quot;. Не изобретайте велосипед и не повторяйтесь. Но теперь пора перейти к следующему шаблону в нашем списке.</p><h3 id="шаблон-callback-обратныи-вызов" tabindex="-1">Шаблон Callback (обратный вызов) <a class="header-anchor" href="#шаблон-callback-обратныи-вызов" aria-label="Permalink to &quot;Шаблон Callback (обратный вызов)&quot;">​</a></h3><p>Шаблон обратного вызова прост для понимания. Он применяется в тех случаях, когда необходимо выполнить операцию после завершения <strong>синхронной</strong> или <strong>асинхронной</strong> операции. Для этого в вызов функции в качестве одного из параметров включается функция, которая должна быть выполнена по завершении операций. При этом необходимо различать следующие два типа потока кода:</p><ul><li>Синхронные операции выполняются последовательно друг за другом. Это основной поток кода, сверху вниз.</li><li>Асинхронные операции выполняются вне обычного потока после их вызова. Их продолжительность неопределенна, равно как и успех или неудача.</li></ul><p>Именно для асинхронных случаев особенно полезен шаблон <em>callback</em>. Вспомним, например, сетевой вызов. После вызова мы не знаем, сколько времени потребуется для получения ответа от сервера и будет ли он успешным, неудачным или приведет к ошибке. Если бы у нас не было асинхронных операций, наше приложение было бы <em>заморожено</em>, ожидая, пока произойдет разрешение. Это было бы не очень удобно для пользователя, хотя с вычислительной точки зрения это было бы правильно.</p><p>Одной из важных особенностей JavaScript является то, что, будучи однопоточными, асинхронные функции не блокируют основной поток, позволяя продолжить выполнение. Это важно, поскольку функции рендеринга браузера работают в одном потоке. Правда, это не бесплатно, так как они потребляют ресурсы, но зато не приводят к зависанию пользовательского интерфейса, по крайней мере, в теории. На практике это будет зависеть от ряда факторов, в значительной степени зависящих от среды браузера и аппаратного обеспечения. Тем не менее, давайте придерживаться теории.</p><p>Рассмотрим пример синхронной функции обратного вызова и превратим ее в асинхронную. Пример функции очень прост: мы будем вычислять значение Фибоначчи для заданного числа, используя шаблон обратного вызова. Но сначала напомним формулу вычисления:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">F</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">F</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">F</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> F</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">F</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), причем n</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span></span></code></pre></div><p>Здесь представлена функция JavaScript, которая применяет формулу и получает обратный вызов для возврата значения. Обратите внимание, что эта функция является синхронной:</p><h4 id="chapter-2-callback-1-js-синхронныи-фибоначчи" tabindex="-1">./chapter 2/callback-1.js - Синхронный Фибоначчи <a class="header-anchor" href="#chapter-2-callback-1-js-синхронныи-фибоначчи" aria-label="Permalink to &quot;./chapter 2/callback-1.js - Синхронный Фибоначчи&quot;">​</a></h4><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> FibonacciSync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">n</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">callback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    callback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pre_1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pre_2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pre_1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pre_2;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      pre_1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pre_2;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      pre_2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    callback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Заметьте, что вместо того, чтобы вернуть значение с помощью <strong>return</strong>, мы передаем его в качестве параметра функции <strong>callback</strong>. Когда полезно использовать такое? Рассмотрим эти простые примеры:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">FibonacciSync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, console.log);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// В консоль будет выведено 21</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">FibonacciSync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, alert);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Будет показано окошко с числом 21</span></span></code></pre></div><p>Заменив функцию обратного вызова, мы можем существенно изменить представление результата. Однако у функции из примера есть фундаментальный недостаток, влияющий на пользовательский опыт. Будучи синхронной, время вычисления пропорционально переданному параметру: чем больше <strong>n</strong>, тем больше времени это займет. При достаточно большом числе мы легко можем &quot;подвесить&quot; браузер, но также, гораздо раньше, можем &quot;заморозить&quot; интерфейс. Проверить синхронность выполнения можно с помощью следующего фрагмента:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Before&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">FibonacciSync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">9</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, console.log);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;After&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Будет выведено:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/*</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    Before</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    34</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    After</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">*/</span></span></code></pre></div><p>Чтобы превратить эту простую функцию в асинхронную, можно просто обернуть логику внутри вызова в <strong>setImmediate</strong>. Это выведет выполнение из обычного рабочего процесса. Теперь новая функция выглядит следующим образом:</p><div class="tip custom-block"><p class="custom-block-title">Совет</p><p>Функция <code>setImmediate()</code> <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/setImmediate" target="_blank" rel="noreferrer">помечена</a> как deprecated в <code>JavaScript</code> <code>Web API</code>, пользоваться ею не стоит.</p></div><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> FibonacciAsync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">n</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">callback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  setImmediate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      callback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pre_1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pre_2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pre_1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pre_2;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        pre_1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pre_2;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        pre_2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      callback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Как видите, мы используем стрелочную функцию, чтобы завернуть код без каких-либо модификаций. Теперь посмотрите на разницу, когда мы выполним тот же сниппет, что и раньше, с этой функцией:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Before&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">FibonacciAsync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">9</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, console.log);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;After&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Будет выведено:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/*</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    Before</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    After</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    34</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">*/</span></span></code></pre></div><p>Как видно из вывода, сниппет выводит <strong>After</strong> раньше, чем <strong>34</strong>. Это происходит потому, что наша асинхронная операция, как и ожидалось, была выведена из обычного потока. При вызове асинхронной функции выполнение <em>не ожидает</em> результата и продолжает выполнять следующую инструкцию. Это может иногда сбивать с толку, но является очень мощным и полезным.</p><p>Однако шаблон не предписывает, как обрабатывать ошибки или неудачные операции, как выстраивать цепочку или последовательно выполнять несколько вызовов. Существуют различные способы решения этих проблем, но они не являются частью шаблона. Существует другой способ обработки асинхронных операций, который обеспечивает большую гибкость и контроль: promises (<em>обещания</em>). Мы рассмотрим его далее, и в большинстве случаев вы можете использовать оба шаблона как взаимозаменяемые. Я говорю &quot;в большинстве случаев&quot;, а не во всех!</p><h3 id="шаблон-promise-обещаниe" tabindex="-1">Шаблон Promise (обещаниe) <a class="header-anchor" href="#шаблон-promise-обещаниe" aria-label="Permalink to &quot;Шаблон Promise (обещаниe)&quot;">​</a></h3><p>Шаблон <em>promise</em> предназначен в первую очередь для работы с асинхронными операциями. Как и в случае с обратными вызовами, вызов обещанной функции выводит выполнение из обычного потока, но возвращает специальный объект <strong>Promise</strong>. Этот объект предоставляет простой API с тремя методами: <strong>then</strong>, <strong>catch</strong> и <strong>finally</strong>:</p><ul><li>Метод <strong>then</strong> получает две функции обратного вызова, традиционно называемые <strong>resolve</strong> и <strong>reject</strong>. Они используются в асинхронном коде для возврата успешного значения (<strong>resolve</strong>) или неудачного или отрицательного значения (<strong>reject</strong>).</li><li>Метод <strong>catch</strong> получает параметр <strong>error</strong> и срабатывает, когда процесс выбрасывает <strong>ошибку</strong> и выполнение прерывается.</li><li>Метод <strong>finally</strong> выполняется в любом случае и получает функцию обратного вызова.</li></ul><p>Во время выполнения обещания оно находится в <em>неопределенном</em> состоянии до тех пор, пока не будет разрешено или отклонено. Время ожидания обещания в этом состоянии не ограничено, что делает его особенно полезным для длительных операций, таких как сетевые вызовы и <strong>межпроцессные</strong> <strong>коммуникации</strong> (<strong>IPC</strong>).</p><p>Посмотрим, как реализовать предыдущий пример с рядом Фибоначчи с помощью обещаний:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> FibonacciPromise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">n</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">reject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {           </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      reject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();                                 </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 2</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 3</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pre_1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pre_2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pre_1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pre_2;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          pre_1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pre_2;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          pre_2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>На первый взгляд легко заметить, что реализация немного изменилась. В строке <code>//1</code> мы начинаем с того, что сразу возвращаем объект <strong>new Promise()</strong>. Этот конструктор получает функцию обратного вызова, которая, в свою очередь, получит два обратных вызова с именами <strong>resolve()</strong> и <strong>reject()</strong>. Их мы должны использовать в нашей логике для возврата значения в случае успеха (<strong>resolve</strong>) или неудачи (<strong>reject</strong>).</p><p>Также обратите внимание, что нам не нужно оборачивать наш код в функцию <strong>setImmediate</strong>, поскольку обещание по своей природе является асинхронным. Теперь мы проверяем наличие отрицательных чисел и в этом случае отклоняем операцию (строка <code>//2</code>). Другое изменение, которое мы делаем - это замена <strong>callback()</strong> на <strong>resolve()</strong> (<code>//3</code>).</p><p>Вызов теперь также изменяется:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Before&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">FibonacciPromise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">9</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Неопределено для отрицательных чисел!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;After&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Будет выведено:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/*</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    Before</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    After</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    34</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">*/</span></span></code></pre></div><p>Как видите, мы выстраиваем цепочку к вызову, методу <strong>then</strong>, и передаем ему две функции для успеха и неудачи (<strong>resolve</strong> и <strong>reject</strong> в нашем коде). Как и раньше, мы получаем тот же самый результат. Теперь это может показаться более многословным (так оно и есть), но преимущества значительно перевешивают дополнительный набор текста. Обещания можно передавать по цепочке, то есть, при успешном выполнении операции можно вернуть новое обещание и таким образом получить последовательную операцию. Вот пример:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">MyFunction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)}, () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} )</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)}, () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} )</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)}, () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} )</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)}, () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} )</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">err</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><p>У конструктора <strong>Promise</strong> есть и другие методы, например <strong>.all</strong>, но для более глубокого изучения возможностей и синтаксиса я отсылаю вас к <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noreferrer">документации</a>.</p><p>Тем не менее, получается довольно многословно. К счастью для нас, JavaScript предоставляет нам упрощенный синтаксис для работы с обещаниями, <strong>async/await</strong>, считая их способом кодирования более &quot;традиционным&quot; способом. Это относится только к вызову обещанных функций и может быть использовано только в функциях.</p><p>Для примера представим, что у нас есть три функции, возвращающие обещания, с именами <strong>MyFuncA</strong>, <strong>MyFuncB</strong> и <strong>MyFuncC</strong> (да, я знаю, не самые удачные имена). Каждая из них в случае успеха возвращает <em>одно единственное значение</em> (это условие). Затем они используются внутри <strong>MyProcessFunction</strong> с новым синтаксисом. Вот объявление:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">async</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> myProcessFunction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  try</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 2</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyFuncA</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();                    </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 3</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> b</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyFuncB</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> c</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyFuncC</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 4</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Ошибка&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Вызов функции в обычном режиме</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">MyProcessFunction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();                                </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 5</span></span></code></pre></div><p>Начнем с объявления нашей функции с ключевым словом <strong>async</strong> (строка <code>//1</code>). Это сигнализирует интерпретатору, что мы будем использовать синтаксис <strong>await</strong> внутри нашей функции. Одно из условий - обернуть код в блок <strong>try...catch</strong> (начиная со строки <code>//2</code>). Тогда мы сможем использовать ключевое слово <strong>await</strong> перед вызовом каждой обещанной функции, как в строке <code>//3</code>. К строке <code>//4</code> мы уверены, что каждая переменная получила свое значение. Безусловно, такой подход более удобен для восприятия.</p><p>Исследуем эквивалентности для строки:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyFuncA</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><p>Это будет соответствовать синтаксису <em>thenable</em> (с использованием <strong>.then</strong>):</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">MyFuncA</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">result</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result; });</span></span></code></pre></div><p>Однако проблема с последним синтаксисом заключается в том, что нам необходимо убедиться, что все переменные <strong>a</strong>, <strong>b</strong> и <strong>c</strong> имеют значения, прежде чем мы сможет выполнить строку <code>//4</code>, <strong>console.log(a + b + c)</strong>, что позволяет выстроить цепочку вызовов следующим образом:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a, b, c;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">MyFuncA</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">result</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyFuncB</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">result</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyFuncC</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">result</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result; console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c); });</span></span></code></pre></div><p>Этот формат сложнее для понимания и, конечно, более многословен. Для таких случаев предпочтительнее использовать синтаксис <strong>async/await</strong>.</p><p>Использование обещаний отлично подходит для обертывания длинных или неопределенных операций и интеграции с другими рассмотренными нами шаблонами (façade, decorator и т.д.). Это важный шаблон, который мы будем широко использовать в наших приложениях.</p><h2 id="подведение-итогов" tabindex="-1">Подведение итогов <a class="header-anchor" href="#подведение-итогов" aria-label="Permalink to &quot;Подведение итогов&quot;">​</a></h2><p>В этой главе мы рассмотрели принципы разработки программного обеспечения и важные шаблоны проектирования, привели примеры на обычном JavaScript и, когда это было уместно, намекнули на реализацию с помощью Vue 3. Эти шаблоны могут быть сложны для восприятия при первом знакомстве с ними, но мы будем использовать их и возвращаться к ним в остальных частях книги, так что эта глава будет работать как справочник. Это позволит вам лучше понять, когда и как применять те или иные шаблоны в зависимости от потребностей вашего приложения.</p><p>В следующей главе мы начнем реализовывать проект с нуля и заложим основы для приложений, которые мы будем создавать в остальных частях книги. По мере продвижения вперед мы будем ссылаться на эти шаблоны, чтобы помочь вам закрепить их применение.</p><h2 id="вопросы-для-проверки" tabindex="-1">Вопросы для проверки <a class="header-anchor" href="#вопросы-для-проверки" aria-label="Permalink to &quot;Вопросы для проверки&quot;">​</a></h2><ul><li>В чем разница между принципом и шаблоном проектирования?</li><li>Почему шаблон singleton так важен?</li><li>Как можно управлять зависимостями?</li><li>Какие шаблоны делают возможной реактивность?</li><li>Взаимосвязаны ли шаблоны между собой? Почему? Можете ли вы привести пример?</li><li>Что такое асинхронное программирование и почему оно так важно?</li><li>Можете ли вы придумать примеры использования <em>promised</em> функций?</li></ul>`,292)]))}const C=i(g,[["render",o]]);export{D as __pageData,C as default};
